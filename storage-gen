#!/usr/bin/env zsh

SUMMARY=$(<< \
'------------------------------------------------------------------------------'
WARNING: This code is under live development RIGHT NOW...
this notice will be removed once it reaches a beta release state.

Name: storage-gen

Description: Generate linux storage structures from minimal definition files

Author: Ethan Schoonover <es@ethanschoonover.com>

Bug-Reports: http://github.com/altercation/storage-gen/issues

Summary:

storage-gen takes a *storage definition file* and processes it into valid
general purpose linux storage initialization commands for disk partitioning,
filesystem creation, encryption, etc. It performs basic validation and will
infer obvious values and sane defaults, unless instructed not to, and then
gift wraps the output as an executable script for review/use. There is also
a useful tree view output and live view.

Try It:

Having booted the Arch Linux install medium, download the storage-gen script
with the following command

    # curl -L http://links.ethanschoonover.com/storage-gen | zsh
    # storage-gen --help

To create a configuration script for a typical new Arch Linux system, you
could use the following commands (these only output text or tree information,
**they do not execute any changes to the system**)

    # storage-gen new-simple
    # storage-gen new-simple --tree

If you had an existing system with, for example, a home partition you wanted
to keep, while erasing everything else and reinstalling the system, you could
use this

    # storage-gen keep-home --tree


## It does what?

### This command

    # storage-gen new-simple --tree

### Processes this template file

    filesystem --size 20G --mountpoint /
    filesystem --mountpoint /home
    swap

### Creating this structure automatically

    [drive] devpath=/dev/sdb
       │  
       ├──[partition] size=20G devpath=/dev/sdb1 partnum=1
       │  │  
       │  └──filesystem fstype=ext4 devpath=/dev/sdb1 mountpoint=/
       │  
       ├──[partition] size=ram devpath=/dev/sdb2 partnum=2
       │  │  
       │  └──swap devpath=/dev/sdb2
       │  
       └──[partition] size=max devpath=/dev/sdb3 partnum=3
          │  
          └──filesystem fstype=btrfs mountpoint=/home devpath=/dev/sdb3

### While this command (without --tree)

    # storage-gen new-simple

### Automatically creates this script

Note that it does **not** automatically run this script. You may save it via standard output redirection or using the `--output` command line option. This gives you the important opportunity to review the output and make changes to either the template or the raw script output itself.

    #!/usr/bin/env zsh

    # ----------------------------------------------------------
    # storage initialization commmands
    # ----------------------------------------------------------

    # Drive formatting and partition structures
    # ----------------------------------------------------------
    sgdisk --new=1:0:+20G  # create fixed size partition
    sgdisk --new=2:0:16G   # create partition matching system ram size
    sgdisk --largest-new=3 # create partition filling remaining space

    # Swap configuration
    # ----------------------------------------------------------
    # Get swap uuid (add --label on swap to use instead)
    swap_uuid="$(lsblk -no UUID /dev/sdb2)" # no label, get uuid
    mkswap -U $swap_uuid /dev/sdb2          # make swap device
    swapon -U $swap_uuid /dev/sdb2          # activate swap device

    # Filesystem creation
    # ----------------------------------------------------------
    mkfs.ext4 /dev/sdb1           # make filesystem
    mkfs.btrfs --force /dev/sdb3  # make filesystem

    # Mount filesystems & create subvolumes
    # ----------------------------------------------------------
    mount /dev/sdb1 /mnt
    mount defaults,x-mount.mkdir,compress=lzo,space_cache,autodefrag,\
        inode_cache /dev/sdb3 /mnt/home

(some comments removed... remove them all with the `--compact` command line option)

## Ok, so what else can it do?

* Handles many different storage configurations

* Allows you to identify partitions that you want to keep

* Allows you to replace partitions with new content

* Encrypts

* Understands most of what you throw at it via the templates

* Knows what you need... you want a filesystem and a swap? It figures
  out what partitions, etc.

Templates:

In the above examples, the `new-typical` and `keep-home` command line
arguments are names of files in the `templates` subdirectory. You can use
your own files as well, or even use a remote file as long as `curl` can
reach it (for example `storage-gen http://myserver.net/myfiles/mytemplate`).

storage-gen templates are intended to be as minimal as possible. They are
like small text-format outlines, each line of which is a storge element
which in turn my have certain values associated with it. For example, here
is a *very* simple template that just formats a drive and makes a filesystem,
then mounts it under our mountpoint (/mnt by default) for subsequent system
installation

    filesystem --mountpoint /

Of course we may want to separate out the root and home partitions, and
limit the amount of space the root partition uses

    filesystem --mountpoint / --size 20G
    filesystem --mountpoint /home

Or create the same thing but using btrfs subvolumes (so no size is
necessary as they will fall under a single partition)

    filesystem
        subvolume --mountpoint /
        subvolume --mountpoint /home

Here is a variation that makes an encrypted partition for home and
adds in a swap partition, which will default to the system ram size

    filesystem --mountpoint / --size 20G
    filesystem --mountpoint /home --encrypt
    swap

Here is another similar configuration that tells the system to
keep the existing home partition untouched and to replace the
existing system root partition with a new installation

    filesystem --replace --label root --mountpoint /
    filesystem --keep    --label home --mountpoint /home --encrypt
    swap

You can mix in --keep and --replace partitions with the creation of
new partitions

    filesystem --keep    --devpath /dev/sda1 --mountpoint /boot
    filesystem --replace --devpath /dev/sda2 --mountpoint /
    filesystem --keep    --devpath /dev/sda3 --mountpoint /home --encrypt
    filesystem --mountpoint /media

The previous examples would have prompted the user to select the
paritions that we wished to keep or replace. We can pre-select
partitions on the current system by providing details about the
partitions (code, size, label). Here we use labels and code values
to help the script figure out which partitions we mean

    filesystem --keep    --code ef00  --mountpoint /boot
    filesystem --replace --label root --mountpoint /
    filesystem --keep    --label home --mountpoint /home --encrypt

Another option would have been to specify a partition
number

    filesystem --keep    --partnum 1 --mountpoint /boot
    filesystem --replace --partnum 2 --mountpoint /
    filesystem --keep    --partnum 3 --mountpoint /home --encrypt

In this partnum example, the script would prompt interactively for a
drive to be selected. We could add this information directly to the
template if we wanted to

    drive --devpath /dev/sda
        filesystem --keep    --partnum 1 --mountpoint /boot
        filesystem --replace --partnum 2 --mountpoint /
        filesystem --keep    --partnum 3 --mountpoint /home --encrypt

or to each filesystem (and thus the containing parition)

    filesystem --keep    --devpath /dev/sda1 --mountpoint /boot
    filesystem --replace --devpath /dev/sda2 --mountpoint /
    filesystem --keep    --devpath /dev/sda3 --mountpoint /home --encrypt

or we could have provided this information on the command line

    storage-gen my-template --drives "/dev/sda,/dev/sdb"

If the pre-specified drives are not valid for installation, the script
will prompt for other drives to be selected (prudence). If, however,
you are (for example) running the script on a machine that is not the
installation target, you might want to ignore the actual system
environment for the time being

    storage-gen my-template --drives "/dev/sda,/dev/sdb" --just

Finally, if you want the script to then just pick the first available
drive and skip asking you so many questions, tell it to not query

    storage-gen my-template --drives "/dev/sda,/dev/sdb" --just --guess

Outline Your Storage:

Storage template files are really just outlines. You can indent (spaces
OR tabs, not both, and spaces are recommended) in order to provide
information about which element goes where. For example

    drive   # oh yeah, comments are ok
        partition --size 200M
            filesystem --mountpoint /boot --fstype vfat
        partition
            # filesystem  (this filesystem is commented out
            #              but the script knows we need one
            #              there so it will make one)
                subvolume --mountpoint /
                subvolume --mountpoint /home

If you wanted to be lazy about things, the following is
equivalent

        filesystem --size 200M --mountpoint /boot --fstype vfat
        subvolume --mountpoint /
        subvolume --mountpoint /home

A nice tool is the `--tree option` that would show you a structured
preview of what your template will create

Trust but Verify:

storage-gen is non-destructive. It merely outputs a script that can (and
must) be reviewed prior to execution. You can run storage-gen on a live
system safely. However the final output script is potentially dangerous
in that it makes partition changes. It is absolutely your own responsibility
to make sure the final script does what you want it to!

Requirements:

Init-storage expects certain linux utilities (lsblk, mount, mkfs.*) as well
as zsh. An aside: Why zsh? Init-storage was written primarily for use on new
Arch Linux installations, and zsh is the default shell on the Arch install
medium. Zsh is a capable and well documented scripting language, albeit
it one prone to hieroglyphic like parameter expansions. Regardless, something
of this scope may be best rewritten in another language.

Intended Systems:

Currently, storage-gen is designed for use on UEFI systems and targets the
creation of GPT partitioned disks.

Usage Example:

Suppose you want to erase your drive, create a new btrfs file system for
your system root and also create a new, separate filesystem for your home
directory. A storage-gen definition file for this might be:

    filesystem --fstype btrfs --size 30G --mountpoint /
    filesystem --mountpoint /home

If this file was named "mystorage" you could then run storage-gen on it

    # storage-gen mystorage

And after being asked which of the available drives you wanted to use, the
following script would be output

    #!/usr/bin/env zsh
    sgdisk --zap-all /dev/sda # erase everything!
    sgdisk --clear /dev/sda   # create new gpt structure
    sgdisk --new=0:0:+30G     # new partition
    sgdisk --largest-new=0    # new partition, fills remainder
    mkfs.ext4 /dev/sda1       # make a filesystem
    mkfs.ext4 /dev/sda2       # make a filesystem
    mount defaults,x-mount.mkdir/dev/sda1 /mnt      # mount filesystem
    mount defaults,x-mount.mkdir/dev/sda2 /mnt/home # mount filesystem

You could also ask to see a tree style output of the results. This is
useful while writing storage-definition files so you can confirm the
results (for example, with an editor in one terminal or virtual console
and the tree view in another):

    # storage-gen --tree mystorage

Or the same without messages--

    # storage-gen --tree --quiet mystorage

Resulting in the following for a drive selection of /dev/sda

    drive devpath=/dev/sda
    │  
    ├── partition size=30G devpath=/dev/sda1
    │   │  
    │   └── filesystem fstype=btrfs mountpoint=/
    │  
    └── partition size=max devpath=/dev/sda2
        │  
        └── filesystem fstype=ext4 mountpoint=/home

If we wanted do do the same, but use a value of /dev/sdb, without choosing
it manually we could either insert it into our file:

    drive --devpath=/dev/sdb
    filesystem --size 30G --mountpoint /
    filesystem --mountpoint /home

or we could append it to the command line using the `--drives` option which
takes a comma separated list of drives:

    storage-gen --drives /dev/sdb  mystorage

Command Examples:

Note that several of these examples use the example storage template named
'new-typical'. This is only one example file. See other samples in the
'templates' subdirectory, or write your own.

Examples: Ways to reference the storage file - normal script output

    storage-gen filename-from-storage-subdirectory
    storage-gen ./relative/path/to/storage-definition-filename
    storage-gen /full/absolute/path/to/storage-definition-filename
    storage-gen http://url/of/file/to/download

Example: Show a minimal script output, no messages

    storage-gen --commentsoff --quiet new-typical

Example: Live tree output with 'watch'

This is useful for split screen editing, with the storage definition file
open in an editor on one side and this live view in another.

    watch -cn1 'storage-gen --tree new-typical'

Example: Save script file and show output together

    storage-gen new-typical > my-storage-script

or

    storage-gen new-typical --output my-storage-script

See the $SCRIPTROOT/storage subdirectory for a list of prepared storage
definition files and further details on format.

## Existing Partitions

You may wish to keep an existing partition (and whatever it contains) as it is.
For example, you might have an existing filesystem that you want to mount under
/home. To do this, just add the --keep option

    filesystem --mountpoint /home --keep
------------------------------------------------------------------------------)

:<< \
------------------------------------------------------------------------------
MINI CODE STYLE GUIDE

(TODO: revised, but not yet fully implemented)

parameter_name_     trailing underscore indicates a parameter reference
                    (i.e. a name of a parameter)

parameter_name_a_   inidicates an array parameter reference

parameter_name_aa_  indicates an associative array parameter reference

GLOBALS             Global values are always in uppercase but should be
                    restricted to use within the __MAIN function. Outside 
                    __MAIN no globals should be referenced directly. They
                    should always be passed as arguments

allFunctions        function names are camel case
FunctionName        global functions begin with uppercase
functionName        functions local to functions begin with lowercase

local_var           local variables are underscore separated, lowercase

__FunctionName      function names prefixed by a double underscore are first
                    order functions called by __MAIN.

functionName__helperFunction    function names with an infixed double underscore
                    are first order helpers (directly called by the first order function

functionName_helperFunction    function names with an infixed single underscore are
                    second order helpers (called within first order helpers) and are
                    so prefixed/infixed just to namespace them for organization and
                    code management purposes

All functions should take named arguments when possible, primarily through
the use of the helper function localopts which will ensure that all options
passed to the function are set as function local parameters.

All values passed to first order (__prefixed) functions should be parameter
references. This is for consistency. While values could be passed for scalar
parameters, arrays and associative arrays cannot be passed as arrays and thus
must be passed as references. Best to normalize all options for these first
order functions as parameter references.

All values passed to second order functions should be actual parameter values
not reference values (other than arrays).

TODO:
1. suffix all parameter references with _
2. finish passing parameter names TO __process... function so that no
   magic happens in that function... it must merely take references and
   "return" the assigned parameters
3. finish converting global functions to the uppercase format

TODO: no code format related:
make YES to all option act like that... i.e. run all queries, just make
then default to yes or first best answer.

remove escaped newlines within double brackets!

make a "getDrivePath" function that returns correct value for each
type
make a getDrivePath function, same, just more specific
------------------------------------------------------------------------------

:<< \
------------------------------------------------------------------------------
PRELOAD
SCRIPT ENVIRONMENT & DEFAULT VALUES
MAIN EXECUTION
Preloads the entirety of the script so function defintion order becomes
irrelevant. Aliases must still be defined prior to any functions that
use them however. Of course better to avoid aliases and use functions.
------------------------------------------------------------------------------
(( ${(P)+${:-PRELOAD_${s::=${${0:t}//-/}}}} )) || { typeset PRELOAD_$s;
. $(readlink -f $0); __MAIN $0 $*; exit; }

__MAIN () {

    setopt \
        DEBUG_BEFORE_CMD \
        ERR_EXIT \
        EXTENDED_GLOB \
        GLOBAL_EXPORT \
        NO_CONTINUE_ON_ERROR \
        NO_ERR_RETURN \
        NO_LOCAL_TRAPS \
        NO_UNSET \
        NULL_GLOB \
        TYPESET_SILENT \
        WARN_CREATE_GLOBAL

    zmodload zsh/regex zsh/zutil

    # __MAIN expects $0 to be passed as first positional argument
    # so convert it to script parameters and shift it out of args
    typeset -g SCRIPTNAME="${${SCRIPTPATH:=$(readlink -f $1)}:t}"
    typeset -g SCRIPTROOT="${SCRIPTPATH:h}"
    typeset -g SCRIPTTEMP="$(mktemp -d "/tmp/${SCRIPTNAME}-XXXXXX")"
    shift

    typeset -g ISSUES_EMAIL=storage-init@ethanschoonover.com
    typeset -g ISSUES_URL=http://github.com/altercation/storage-gen/issues

    # -----------------------------------------------------------------
    # Create command line script options and associated help information
    #
    # The OPTS_* arrays below determine the actual processed options as well
    # as the help output. Each UPPERCASEOPTION is converted to a --lowercase
    # the command line value of which is assigned to the UPPERCASE parameter
    # name. Standard OPTS_* items are also set with a single letter short
    # form in lowercase (e.g. -l) unless they are in the *_ALT arrays, which
    # are set using uppercase short form (e.g. -U). *_ALT arrays contain
    # alternate options that are uppercased as single letter options (long
    # options remain lowercase as they are, or should be, unique).
    #
    # --help and --usage display the short and long options computed from the
    # arrays below. any *_ARG_* values (options with an argument) will output
    # with the first line of the description as the argument placeholder.
    # --help displays a brief version of each description consisting of the
    # first line only of item.

    makeOptArray () { typeset -Ag $1; typeset -ag OPTARRAYS; OPTARRAYS+=($1) }
    makeOptArray OPTS_BOOL
    OPTS_BOOL=(

    HELP        "Show summary of help information.
                 Use --usage for expanded help."

    YES         "No interactive queries (pick the first 'best' answer
                 for potential queries. For example, for missing drive
                 entries, pick the first available, unmounted, internal
                 drive). This option won't work with the --skip option
                 since --yes still requires information about the current
                 system environment."

    LIST        "List builtin $SCRIPTNAME templates."

    SKIP        "Skip checking the current system.
                 Disregards the current systems drive and partition environment.
                 Allows script to create output based on *only* the provded
                 template (and any --drives option values provided on the
                 command line). If you want a script that isn't valid for
                 the current system (because either it's for an entirely
                 different system configuration or because the target
                 installation target is currently mounted), use this option.  
                 Because the current system is being ignored, no interactive
                 queries for missing values will be run in this mode."

    COMPACT     "No comments in the final script.
                 Turns off all comments and blank lines in the script output.
                 Removing these does not change the functionality of the final
                 script."

    QUIET       "No messages or warnings.
                 Only display actual script (or tree) output, skip informational
                 messages (the informational messages will still be output in the
                 script itself unless the --commentsoff option is selected. With
                 this option, a single error message will be output to standard
                 error if the script fails."

    TREE        "Print tree diagram of output.
                 After evaluating the storage template, a tree relationship is
                 displayed with colors indicating key values (unless --nocolors
                 has been used). Useful in combination with the something like
                 \`watch -cn1\'. This option precludes final script output unless
                 either the --script or --output options have also been provided."

    USAGE       "Displays detailed usage information.
                 Adds a summary of the types of options and arguments that are valid
                 for each storage type entry. Redirect to a file or pipe through a
                 pager such as less. See also the $SCRIPTNAME README available in
                 the project git repository."

    ADVANCED    "Like --help, but includes advanced options."

    )
    makeOptArray OPTS_ARGS
    OPTS_ARGS=(

    DRIVES      "'/dev/sdX,/dev/sdY'
                 List of drive paths to use for drive items in the template
                 (or *implied* drives - you don't need an actual drive entry).
                 This is precisely like adding a drive --devpath /dev/sdX
                 entry in the template (or adding a --devpath field to an
                 existing drive entry). THIS OVERRIDES EXISTING --devpath
                 VALUES IN THE TEMPLATE! Without this option or actual
                 --devpath values in the template file, the user will be
                 prompted to select drives from the live system (if then
                 --just option hasn't been set and if --guess isn't set)."

    MOUNTROOT   "'/MOUNT/ROOT/PATH'
                 Preinstall mount root. Default is /mnt.
                 Set mount root directory (if not set, use the default '/mnt').
                 Argument is a valid, absolute path to an existing directory.
                 This path is used during system installation as a chroot  and
                 is *not* recorded in any fstab."

    )
    makeOptArray OPTS_BOOL_ALT
    OPTS_BOOL_ALT=(

    ALPHA       "Whistle on past the alpha warning."

    DEBUG       "Turn on debug tracking; always save debug log.
                 This option turns on minimal debug tracking and rolling script
                 trace capture (in case of error). This has a minimal performance
                 impact so is normally off. The debug log is saved by by default
                 if the script encounters an error, and the debug file path will be
                 displayed in that case or with the use of this option. This debug
                 file contains the block device configuration and the original
                 template file content. It may be submitted with bug reports."

    KEEP        "Keep all existing partitions.
                 Prevents disk formatting, even if no actual
                 '--keep' or '--replace' options have been set on
                 partitions in the template. Without at least one partition
                 with one of those options OR this command line option, the
                 final script will include a disk format command. With this
                 option on the command line, no disk formatting will occur
                 and existing partitions will be preserved (unless --replace
                 has been specified for a partitio)."

    FORCE       "Force the script to always output to console.
                 This happens by default UNLESS either the --tree or --output
                 options have been passed on the command line. In these cases,
                 passing the --script option restores the visual output of the
                 script as well."

    README      "Output usage in README markdown format."

    COLOROFF    "Do not use colors in console output."

    INFEROFF    "Turn off inference of missing values."

    LISTCODES   "List GUID type codes in short and long."

    MULTIPASS   "Output individual passphrase query blocks.
                 If multiple encryption items exist $SCRIPTNAME normally creates a
                 single passphrase query in the final executable script. With this
                 option, each encryption device without a preset passphrase will
                 receive a separate passphrase query step in the final script.
                 Yes, it's a multipass,"

    NOMATCH     "No matching existing partitions.
                 Normally, if the --keep or --replace option has been specified
                 (or inherited) by a partition entry in the storage template (or
                 a partition implied by another entry), $SCRIPTNAME will make
                 best effort to match it to an existing partition based on
                 available information in the template and on the system itself.
                 See the --usage section on matching for more information."

    ENVDEBUG    "Dump environment values for debugging."

    VERBOSE     "Display details during processing."

    WARNOFF     "Turn off warning query in script output."

    )
    makeOptArray OPTS_ARGS_ALT
    OPTS_ARGS_ALT=(

    OUTPUT      "OUTPUT_FILE_NAME
                 Optional output filename.
                 If this option is provided, the final executable script will be
                 written to the path provided. If not set, script is displayed on
                 standard output and may be saved using redirection."

    SOURCEDEBUG "FILENAME
                 Simulate environment from debug file.
                 $SCRIPTNAME will read the captured debug output from the provided
                 file and use it to simulate a system environment. Simulated values
                 include the block device configuration and the original template
                 file content."

    TEMPLATE    "TEMPLATE_FILE_PATH
                 Alternative syntax for source template.
                 $SCRIPTNAME normally uses arg 1 (the first 'unnamed' argument) on
                 the command line as the name (or path) of the template to use.
                 This option is merely a more explicit alternative to that."

    )
    # currently unused, these provide optional zparseopts options
    # it should be noted that these don't work on the command line if there is
    # any space between the option and value, so '--myoptional value' will return
    # true, not "value" (which will remain in the options list). The correct form
    # for optional values is without a space, so: "--myoptionalvalue" or "-mvalue"
    # or "-m=value" or "--myoptional=value".
    makeOptArray OPTS_OPT
    makeOptArray OPTS_OPT_ALT

    # original command line options were passed to the __MAIN function
    typeset -a COMMAND_LINE_OPTIONS
    COMMAND_LINE_OPTIONS=($*)

    __InitializeScriptOptargs \
        --command_line_                 COMMAND_LINE \
        --command_line_options_a_       COMMAND_LINE_OPTIONS \
        --global_option_definitions_a_  OPTARRAYS \
        --script_name_                  SCRIPTNAME \
        --drives_option_                DRIVES \
        --input_option_                 INPUT \
        --input_template_               INPUTFILE

    __InitializeColor \
        --nocolor_option_               COLOROFF \
        --return_color_a_               COLOR

    __InitializeMountroot \
        --return_mountroot_             MOUNTROOT

    __InitializeTrapsAndLog \
        --command_line_                 COMMAND_LINE \
        --debug_option_                 DEBUG \
        --debug_log_                    DEBUGLOG \
        --debug_report_email_           ISSUES_EMAIL \
        --debug_report_url_             ISSUES_URL \
        --input_filename_               INPUTFILE \
        --input_filepath_               SOURCEFILE \
        --input_fileraw_                FILERAW \
        --storage_tree_                 STORAGE \
        --system_data_                  SYSTEM \
        --storage_tree_                 STORAGE \
        --script_name_                  SCRIPTNAME \
        --script_temp_                  SCRIPTTEMP

    __InitializeStorageFunctions \
        --storage_tree_                 STORAGE

    __InitializeRulesets

    # -----------------------------------------------------------------
    # terra incognita warning

    __AlphaWarning

    # -----------------------------------------------------------------
    # drop out for usage/help. usage reads data from the rulesets
    # as well, so we run this after those have been read in.

    ${USAGE:-false}     && { __Usage;                   exit 0 }
    ${README:-false}    && { __Usage --readme;          exit 0 }
    ${ADVANCED:-false}  && { __Usage --mini --advanced; exit 0 }
    ${HELP:-false}      && { __Usage --mini;            exit 0 }
    ${LISTCODES:-false} && { __Usage --listcodes ;      exit 0 }
    ${LIST:-false}      && { __ListTemplates;           exit 0 }

    # -----------------------------------------------------------------
    # if using a debug log file, source it here. it may contain
    # block device environment data and (possibly) source template
    # raw file data. whatever values are present will be used
    # in the remainder of the script in lieu of otherwise provided
    # or present information.
    #
    # TODO: implement local to global conversion in function
    execute __SourceDebugLog \
        --source_file_          SOURCEDEBUG \
        --return_system_data_   SYSTEM      \
        --return_fileraw_       FILERAW

    # -----------------------------------------------------------------
    # skip scanning the system environment if we already read in this data
    # via the --sourcedebug option OR if the --just (just use the
    # template data) option has been set (unless --envdebug is in play
    # in which case we always grab the environment data, though again
    # this might be the *simulated* data from a log file).
    if [[ -z ${SYSTEM:-} ]] && ( ! ${SKIP:-false} || ${ENVDEBUG:-false} )
    then

        # -------------------------------------------------------------
        # write current block device environment to a structured
        # associative array. from here on out we no longer query
        # the live system (this is faster than repeat live queries
        # and enables system configuration simulation via the
        # debug log output and the --sourcedebug option).

        execute __CaptureEnvironment          \
            --return_array_ SYSTEM

    fi

    # -----------------------------------------------------------------
    # dump the current environment (or the simulated environment)
    # to a human readable format. this is a combination of lsblk
    # and sgdisk data and makes it easier to scan both live system
    # configuration and debug logs.
    ${ENVDEBUG:-false} && {
        debugDump --array SYSTEM
        exit 0
    }

    # -----------------------------------------------------------------
    # skip reading in the file if we already read in this data
    # via the --sourcedebug option
    [[ -n ${FILERAW:-} ]] || {

        # -------------------------------------------------------------
        # handle path variations (absolute, relative, remote)
        # and output a normalized local absolute path
        execute __FileLocate                      \
            --original_filepath_    INPUTFILE   \
            --return_filepath_      SOURCEFILE  \
            --tmpdir_               SCRIPTTEMP  \
            --debugmode_            DEBUG       \
            --root_                 SCRIPTROOT

        # -------------------------------------------------------------
        # read the raw file into an array for processing
        execute __FileRead                    \
            --source_filepath_      SOURCEFILE  \
            --return_array_         FILERAW   

    }

    # -----------------------------------------------------------------
    # strip out comments and escaped newlines
    # also adds in the --indent value for each valid line

    execute __FileClean                       \
        --source_array_         FILERAW     \
        --return_array_         FILECLEAN 

    # -----------------------------------------------------------------
    # convert the cleaned file data to a tree structured
    # associative array

    execute __FileConvertToArray              \
        --source_array_         FILECLEAN   \
        --return_array_         STORAGE     \
        --ruleset_array_fields_ FIELDS

    # -----------------------------------------------------------------
    # working outwards from each storage type  record in the
    # array, move fields that belong elsewhere to new or
    # existing records, reshuffling and creating as needed

    execute __InflateStructure                \
        --input_storage_array_  STORAGE     \
        --output_storage_array_ STORAGE     \
        --fields_array_         FIELDS      \
        --values_array_         VALUES      \
        --ancestors_array_      ANCESTORS   \
        --children_array_       CHILDREN    \
        --descendants_array_    DESCENDANTS \
        --equivalents_array_    EQUIVALENTS \
        --inherit_array_        INHERIT     \
        --valid_array_          VALID

    # -----------------------------------------------------------------
    # limited application of defaults to missing required fields,
    # for example: filesystem --fstype and swap partition --size

    execute __AssumeValues                    \
        --storage_array_        STORAGE     \
        --fields_array_         FIELDS      \
        --inherit_array_        INHERIT     \
        --valid_array_          VALID       \
        --infer_off_option_     INFEROFF

    # -----------------------------------------------------------------
    # unless we want more verbose output in the tree display
    # strip out some of the extra metadata here (notes, etc.)
    # TODO: could move this into the tree print function?

    execute __ScrubStructures                 \
        --storage_array_        STORAGE     \
        --verbose_array_        VERBOSE     \
        --values_array_         VALUES

    # -----------------------------------------------------------------
    # check that basic relationships and required values are
    # present (based on rulesets) - could run this AFTER
    # drives and partitions to validate all in one go, but
    # if there is a failure at this stage other than in
    # partition paths/partnums, then it's good to know before
    # the user wastes time selecting drives, etc.

    () {
    #return 0;
    execute __ValidateStructures              \
        --children_array_       CHILDREN    \
        --required_array_       REQUIRED    \
        --siblings_array_       SIBLINGS    \
        --storage_array_        STORAGE     \
        --valid_array_          VALID
}

    # -----------------------------------------------------------------
    # assign drive paths (e.g. /dev/sda, /dev/sdb)
    # order of assignment is:
    #   1. From --drives command line argument (this effectively just
    #      writes the values into the data so that they may as well have
    #      been in the template all along... it also overwrites any
    #      existing template values)
    #   2. From template
    #   3. Guess or Query
    #       - From best guess if --guess option is set
    #         (e.g. take first available unmounted internal drive)
    #       - Else if no --guess option then from interactive query

    # TODO: this can still take the drives array (--drives) and
    # can override (it isn't right now, I don't think). the override
    # function needs to be written and it needs to override for 
    # the case of selection of a new drive (or am I doing that already?)
    # -- it is essentially the same thing, picking a new drive if the
    # template drive is invalid, and then rewriting the drive paths,
    # or overriding with a drive from the --drives option. I think the
    # --drives option should ALWAYS be respected. It's a club, and
    # the user is hammering the point home: "I want these drives"
    # barring a --replace or --keep partition that is missing a
    # partnum, they should be used regardless.

    # of course I could just write the new drives regardless of
    # anything else, and let the validators sort it out

    execute __AssignDrives                  \
            --storage_tree_     STORAGE     \
            --system_data_      SYSTEM      \
            --drives_override_  DRIVES      \
            --yes_to_all_       YES         \
            --skip_system_data_ SKIP

    execute __AssignPartitions              \
            --system_mapping_   MAPPING     \
            --storage_tree_     STORAGE     \
            --system_data_      SYSTEM      \
            --yes_to_all_       YES         \
            --skip_system_data_ SKIP

    execute __printTree                       \
        --input_array           STORAGE     \
        --tree_option           TREE        \
        --input_filename        INPUTFILE   \
        --input_filepath        SOURCEFILE
    exit

    # -----------------------------------------------------------------
    # validate that the results of the partition processing
    # (no missing devpaths, partnums, they match, etc.)
    # if no --just option, then make sure they exist

    execute __validatePartitions              \
        --drives_array          DRIVES      \
        --input_array           STORAGE     \
        --blockenv_array        SYSTEM      \
        --ignore_env            SKIP

    # create the actual script output with partitioning,
    # filesystem creation, encryption and mounting commands
    execute __genPayload                      \
        --input_array           STORAGE     \
        --outputvar             PAYLOAD     \
        --sourcefile            SOURCEFILE  \
        --infilename            INPUTFILE   \
        --mountroot             MOUNTROOT   \
        --multipass             MULTIPASS   \
        --comments_option       COMPACT     \
        --warning_option        WARNOFF     \
        --ignore_env            SKIP

    # optionally print out a tree representation of the
    # final composed structure
    execute __printTree                       \
        --input_array           STORAGE     \
        --tree_option           TREE        \
        --input_filename        INPUTFILE   \
        --input_filepath        SOURCEFILE

    # by default (and optionally with the --force option)
    # output the script to standard out (with the --output
    # command line option it is saved to the filename provided)
    ((   ${TREE:-false}                     \
    ||   ${ENVDEBUG:-false} )               \
    && ! ${FORCE:-false}    ) ||            {
    execute __printPayload                    \
        --input_array           PAYLOAD     \
        --comments_option       COMPACT     }

}
__AssumeValues () {
    . <(localopts \
        storage_array_: \
        fields_array_: \
        inherit_array_: \
        valid_array_: \
        infer_off_option_:
        )

    ${(P)infer_off_option_:-false} && return 0

    typeset -A infer_warnings

    assumeTypeSpecificValues () {
        . <(localopts start_at:)
        typeset -a children
        children=($(children --in $storage_array_ --of "${start_at:-}"))
        typeset index
        for index in $children
        do
            AssumeValues__AssumeFilesystemValues    \
                --record_index      $index          \
                --infer_warnings_   infer_warnings  \
                --storage_array_    $storage_array_ || return 1
            AssumeValues__AssumePartitionValues     \
                --record_index      $index          \
                --infer_warnings_   infer_warnings  \
                --storage_array_    $storage_array_ || return 1
            $0 --start_at $index || return 1
        done
    }
    while ! assumeTypeSpecificValues; do :; done
    [[ -z ${infer_warnings:-} ]] || fail ${${(o)infer_warnings}[1]}
}
AssumeValues__AssumeFilesystemValues () {
    . <(localopts record_index: storage_array_: infer_warnings_:)
    . <(active $record_index)
    if [[ ${active[type]:-} == filesystem ]]
    then

        typeset field amatch

        # missing mountpoint, fstype, from parent or ancestor
        for field in mountpoint fstype
        do
            if [[ -z ${active[$field]:-} ]]
            then
                if [[ -n ${active[parent,$field]:-} ]] && false
                then
                    setActive $field ${active[parent,$field]}

                    noteByIndex \
                        --array $storage_array_ \
                        --index $active[index] \
                        --note "Moved $field field from ${active[parent,type]} parent"

                    unset "${storage_array_}[$active[parent,index],$field]"
                    return 1
                elif [[ -n ${amatch::=$(ancestorGetMatch $field)} ]]
                then
                    setActive $field ${(P)${:-${storage_array_}[$amatch]}}
                    atype=${(P)${:-${storage_array_}[${amatch%$field}type]}}

                    noteByIndex \
                        --array $storage_array_ \
                        --index $active[index] \
                        --note "Moved $field field from $atype ancestor"

                    unset "${storage_array_}[$amatch]"
                    return 1
                fi
            fi
        done

        # missing fstype, infer from child
        if [[ -z ${active[fstype]:-} \
           && ${(P)${:-${storage_array_}[${active[index]},1,type]}:-} \
           == subvolume ]]
        then
            eval $storage_array_'[$active[index],fstype]=btrfs'
            setActive fstype btrfs
            noteByIndex \
                --array $storage_array_ \
                --index $active[index] \
                --note "Set fstype to btrfs due to subvolume child"
            return 1
        fi

        # missing fstype, set default value
        if [[ -z ${active[fstype]:-} ]]
        then
            setActive fstype ext4
            noteByIndex \
                --array $storage_array_ \
                --index $active[index] \
                --note "Set fstype to ext4 as default value for missing fstype field"
            return 1
        fi
    fi
    
}
AssumeValues__AssumePartitionValues () {
    . <(localopts record_index: storage_array_: infer_warnings_:)
    . <(active $record_index)
    if [[ ${active[type]:-} == partition ]]
    then
        # missing size and is NOT noclobber
        if ( ! activeIsSet size ) && ( ! activeIsNoclobber )
        then

            typeset dsizekey dsize dtype
            typeset -a sibs

            # check for swap descendant for use below
            typeset -A types
            : ${(AA)sizes::=${(Pkv)${:-${storage_array_}[(I)${active[index]},[0-9]##,type]}}}
            typeset swap_descendant=${(k)sizes[(r)swap]%,type}

            # try to get first available size from any descendant
            dsizekey=${(Pk)${:-${storage_array_}[(i)${active[index]},*,size]}:-}
            dsize=${(Pv)${:-${storage_array_}[$dsizekey]}:-}
            dtype=${(Pv)${:-${storage_array_}[${dsizekey%%size}type]}:-}
            if [[ -n ${dsize:-} ]]
            then
                setActive size $dsize
                unsetActive warn
                noteByIndex \
                    --array $storage_array_ \
                    --index $active[index] \
                    --note "Claimed size from ${dtype:-} descendant"
                unset "${storage_array_}[$dsizekey]"
                unset "${infer_warnings_}[$active[index]]"
                return 1

            # if there is a swap descendant, it lacks a size
            # so we infer system ram size
            elif [[ -n ${swap_descendant} ]]
            then
                setActive size ram
                unsetActive warn
                noteByIndex \
                    --array $storage_array_ \
                    --index $active[index] \
                    --note "Set missing size to match system ram due to swap
                            descendant"
                unset "${infer_warnings_}[$active[index]]"
                return 1

            # else count other siblings, if we're alone then max
            # (swap check must be before this)
            elif [[ -z ${(A)sibs::=$(getOtherSiblings $active[index])} ]]
            then

                setActive size max
                unsetActive warn
                noteByIndex \
                    --array $storage_array_ \
                    --index $active[index] \
                    --note "Set paritition size to be maximum available free
                            space as it is the only partition listed"
                unset "${infer_warnings_}[$active[index]]"
                return 1

            # check for conditition of all existing peers
            else

                # a noclobber sibling is assumed to have a size
                # (we don't need to know it since we won't be
                # creating the partition), so we check here for
                # either noclobber or size. if all other partitions
                # have at least one of these values then we can
                # safely assume this single partition that is
                # missing a value is a max size partition
                sibsAreAllFixedSize () {
                    for sib in $sibs
                    do
                        # is this sibling missing both size & noclobber fields?
                        if isSet "${storage_array_}[$sib,size]" ||
                           indexIsNoclobber $sib
                        then
                            # sibling has either a noclobber field or size
                            continue
                        else
                            # sibling item without noclobber or size found
                            return 1
                        fi
                    done
                    return 0
                }
                if sibsAreAllFixedSize
                then
                    setActive size max
                    unsetActive warn
                    noteByIndex \
                        --array $storage_array_ \
                        --index $active[index] \
                        --note "Set partition size to use maximum available
                                space on drive as all other partitions are
                                either either fixed size or are noclobber"
                    unset "${infer_warnings_}[$active[index]]"
                    return 1
                fi

                # any other future all-sibling checks go here

                # we drop out of this loop here with an implicit
                # return 0 as we've now done our best to infer
                # partition values
                eval ${infer_warnings_}'[$active[index]]="
                Unable to infer a size value for a new partition. This is fatal.
                Probable cause is multiple new (no --keep or --replace tag)
                partitions in template with no fixed size (we can only guess
                that one no-size partition is maximum). Consider adding a fixed
                size to at least one partition."'
            fi

        fi
    fi
}

:<< \
------------------------------------------------------------------------------
END MAIN EXECUTION

everything ABOVE comprises main script sequence, everything BELOW is processed
prior to the __MAIN function (so all functions below are defined *prior* to
__MAIN execution. This includes the script environment section immediately
following this, which is within the same scope as the preload.
------------------------------------------------------------------------------


:<< \
------------------------------------------------------------------------------
Main Sequence Functions
------------------------------------------------------------------------------
__InitializeScriptOptargs () {
    . <(localopts \
        command_line_options_a_:        \
        global_option_definitions_a_:   \
        command_line_:                  \
        script_name_:                   \
        drives_option_:                 \
        input_option_:                  \
        input_template_:                )

    # capture the original command line for logging
    typeset -g $command_line_
    eval $command_line_'="${(P)script_name_} ${(Pq-)command_line_options_a_}"'

    # check for collisions in option short/long forms
    typeset case; typeset -a opts cmd; opts=(); cmd=()
    for optarray in ${(P)global_option_definitions_a_}
    do
        [[ $optarray =~ _ALT ]] && case="U" || case="L"
        typeset -a e
        e=( '${(k)='
            $optarray'//(#b)(*)/${${('
            $case')=match}:0:1} ${(L)match}}'
            )
        opts+=(${=${(ej::)e}})
    done
    # compare total number of defined options against total unique options
    # (should be the same, otherwise we have a collision)
    if [[ ${#opts} -gt ${#${(u)opts}} ]]
    then
        typeset opt
        for opt in $opts
        do
            if (( ${(M)#opts:#$opt} > 1 ))
            then
                print "\nSCRIPT OPTION COLLISION:" 1>&2
                if [[ ${(c)#${(Mu)opts:#$opt}} -eq 1 ]]
                then
                    print -- "-$opt --${opts[$((${opts[(i)$opt]}+1))]}" 1>&2
                    print -- "-$opt --${opts[$((${opts[(I)$opt]}+1))]}" 1>&2
                else
                    print -- "-${opts[$((${opts[(i)$opt]}-1))]} -$opt" 1>&2
                    print -- "-${opts[$((${opts[(I)$opt]}-1))]} -$opt" 1>&2
                fi
                break
            fi
        done
        fail "Two $script_name_ options have identical short or long forms;
              Please change one of the option names or move to an ALT
              or long form only option array."
    fi

    # set the command line options to active parameter array for zparseopts
    set -- ${(@P)command_line_options_a_}

    # run zparseopts on all defined script options
    # note that options (the keys of the above options associative array)
    # may be listed in the array either upper or lower case, but the
    # --long options are always presented lowercase, the global variables
    # are always UPPERCASE and the short options are either -l lower or
    # -U upper depending on whether they are in an _ALT array.
    typeset case colon; typeset -a cmd; cmd=()
    for optarray in ${(P)global_option_definitions_a_}
    do
        [[ $optarray =~ _ARG ]] && colon=":" || colon=""
        [[ $optarray =~ _OPT ]] && colon="::"
        [[ $optarray =~ _ALT ]] && case="U" || case="L"
        typeset -a e
        e=('${(k)'
           $optarray'//(#b)(*)/${${('
           $case')=match}:0:1}'
           $colon'=${(U)match} -${(L)match}'
           $colon'=${(U)match}}')
        zparseopts -D -E -- ${=${(ej::)e}}
    done

    # clean up the parsed options and assign to variables matching their names
    # (so that TESTMODE, for example. receives a true/null value, DRIVES
    # receives an array value, etc.)
    for optarray in ${(PM)global_option_definitions_a_:#*_BOOL*}
    do
        typeset -a e
        e=('${(k)'$optarray'//(#b)(*)/${m::=$match}=${${(P)m::=${(P)m:+true}}:-}}')
        typeset -g ${=${(ej::)e}}
    done

    # if the _OPT (optional value) items have been set, see if they need a true
    for optarray in ${(PM)global_option_definitions_a_:#*_OPT*}
    do
        [[ $optarray =~ _ALT ]] && case="U" || case="L"
        for opt in ${(Pk)optarray}
        do
            eval 'typeset so="-${('$case')opt:0:1}" lo="--${(L)opt}"'
            [[ -z ${(P)opt:-} ]] && continue || :
            [[ -z ${(P)opt#$lo} || -z ${(P)opt#$so} ]] && {
            eval 'unset '$opt'; typeset -g '$opt'=true"'} || :
            eval 'unset '$opt'; typeset -g '$opt'="'${${${(P)opt#$lo}#$so}#=}'"'
        done
    done

    # options that take arguments (will end up as arrays)
    for optarray in ${(PM)global_option_definitions_a_:#*_ARG*}
    do
        [[ -n ${(Pk)optarray} ]] && eval typeset -ag ${(Pk)optarray} || continue
        eval ${(Pk)optarray//(#b)(*)/$match=(${${(P)${:-${match}[2]}:-}#=})}
    done

    # check remainder of command line; should have only one option
    # (positional only) with no leading - or --
    [[ -n $* ]] && {
        typeset -a uo; uo=(${(M)*:#-*})
        [[ -n $uo ]] && {
            __Usage --mini
            fail "Unknown command line option${uo[2]:+s}: $uo"
            }
        }

    # the input file can be set by --input or arg 1
    typeset -g ${input_template_}
    if [[ -n ${(P)input_option_:-} ]]
    then
        # if input template name was supplied with --input option
        eval ${input_template_}'=${(P)input_option_}'
    else
        # else if it was positional
        eval ${input_template_}'=${1:-}'
        # shift the options so we can run a check on leftover
        # command line content (below)
        [[ -n ${1:-} ]] && shift || :
    fi

    # we shouldn't have any left over command line arguments.
    # if we do, fail
    [[ -z ${*:-} ]] || fail "Unknown command line content: $*" 

    # Convert DRIVES values from csv
    [[ -z ${(P)drives_option_:-} ]] || {
    eval $drives_option_'=(${=${(s:,:)${(P)drives_option_}}})' }
}
__InitializeColor () {
    . <(localopts \
       return_color_a_: \
       nocolor_option_: )
    # Prep color array, otherwise no color values if coloroff is set
    if ! ${(P)nocolor_option_:-false}; then
        typeset -Ag $return_color_a_
        autoload colors; colors
        for color in ${(k)fg_no_bold}; do
            eval $return_color_a_'[$color]=${fg_no_bold[$color]}'
            eval $return_color_a_'[$color,bold]=${fg_bold[$color]}'
        done
    else
        unset $return_color_a_
    fi
}
__InitializeMountroot () {
    . <(localopts \
       return_mountroot_: )
    # Make sure we have user specified or default mountroot directory
    typeset m="${(P)return_mountroot_:-}"
    # we're going to either assign or reassign as a scalar and it comes
    # in as an array from our options processing
    # so unset first, then assign existing or default value
    # TODO: this could be a one liner if I unset inside an assignment
    # or possibly if I force set?
    unset $return_mountroot_; typeset -g $return_mountroot_="${m:-/mnt}"
    [[ ${(P)return_mountroot_} =~ "/" ]] || {
        $return_mountroot_="${$(pwd)%/}/${(P)return_mountroot_}" }
    [[ -d ${(P)return_mountroot_} ]] || {
        __Usage --mini
        fail "ERROR: Mountroot directory ${(P)return_mountroot_} not found."
        }
}
__InitializeTrapsAndLog () {
    . <(localopts \
        command_line_: \
        debug_log_: \
        debug_option_: \
        debug_report_email_: \
        debug_report_url_: \
        input_filename_: \
        input_filepath_: \
        input_fileraw_: \
        script_name_: \
        script_temp_: \
        storage_tree_: \
        system_data_: )
    # debug log and a path to move it to if script fails
    # (so don't make user re run with --debug on a bad error)
    # DLHOST=${SCRIPTNAME}${${(%)${:-%D}}//-/}.debug
    # DLTIME=${SCRIPTNAME}${HOST:+-}${HOST:-}.debug
    typeset debug_log_base=${(P)script_name_}.debug
    typeset debug_log_save=/tmp/$debug_log_base
    typeset -g $debug_log_=${(P)script_temp_}/$debug_log_base
    if [[ -e $debug_log_save ]]
    then
        rm -f $debug_log_save || \
        fail "Cannot remove existing debug log at $debug_log_save"
    fi

    # prep debug log header
    typeset -a debug_log_header
    debug_log_header=(
    "# ${(UP)script_name_} DEBUG LOG"
    "# DATE:         $(date)"
    "# RUN AS:       ${${(M)USERNAME:#root}:-non-root}"
    "# ZSH VERSION:  $ZSH_VERSION"
    "# COMMAND LINE: ${(P)command_line_}"
    "# SUBMIT TO:    ${(P)debug_report_email_}\n"
    "# SUBMIT TO:    ${(P)debug_report_url_}\n"
    "typeset -gA $system_data_"
    "typeset -ga $input_fileraw_"
    )
    print -l -- $debug_log_header > ${(P)debug_log_}

    # turn off execution tracking if debug isn't active
    if ${(P)debug_option_:-false}
    then
        execute () {
            typeset -ag ROLLCALL; ROLLCALL+=($1)
            ${QUIET:-false} || {
            print -n ${COLOR[cyan]:-} 1>&2
            print -n "\\n...${(C)${${1#__}//(#m)[A-Z]/ ${(L)MATCH}}}..." 1>&2 }
            print ${COLOR[default]:-} 1>&2
            eval $@ }
    else
        execute () { eval $@ }
    fi

    eval 'TrapCleanup  () {
            typeset dlog='${(P)debug_log_}' stemp='${(P)script_temp_}';
            if [[ -f ${dlog:-} ]]
            then
                if [[ -n ${ROLLCALL:-} ]]
                then
                    print -l -- "# "${^ROLLCALL} >> ${dlog:-/dev/null};
                fi
                if [[ -n $(functions reportLog) ]]
                then
                    ( reportLog >> ${dlog:-/dev/null} ) || :
                fi
                ( ! ${'$debug_option_':-false} ) || {
                    mv $dlog ${debug_log_save::=/tmp/${dlog:t}};
                    print -n "${COLOR[default]:-}" 1>&2;
                    print "Debug log saved to $debug_log_save\n" 1>&2;
                    print "Log may be submitted to: '${(P)debug_report_email_}'"
                    print "or pasted (after a description) into a new issue at:" 1>&2; 
                    print "'${(P)debug_report_url_}'" 1>&2;
                    print "(e.g. with '\''xclip -se c $debug_log_save'\'')\n" 1>&2;
                };
            fi
            if [[ -d ${stemp:-} ]]
            then
                    rm -rf $stemp
            fi
            }'

    # using zshexit for script cleanup since TRAPEXIT runs on every function
    # exit
    # xxx
    eval 'zshexit () {
            (( $status > 0 )) \
            && '$debug_option_'=true;
            TrapCleanup;
            }'
#    eval 'trap '\''(( $status>0 )) && '$debug_option_'=true; TrapCleanup;'\'' EXIT'

    eval 'TRAPERR () {
            teelog --category UNHANDLED_ERROR --color red \
                "$(print -l -- ${ROLLING:-})";
            '$debug_option_'=true; TrapCleanup; debugDump;
            print -n "\n${COLOR[red]:-}" 1>&2;
            print "Exit due to unhandled error." 1>&2; }'

    # ugly. if a command is not found in a function being used by a
    # conditional (or at least certainly in an if... block) I cannot
    # identify the correct method of forcing a full exit, not just
    # returning an error code. there must be a better way. TODO
    eval 'command_not_found_handler () { '$debug_option_'=true;
            print "\n$1 - Command not found. Terminating script.\n" 1>&2;
            TrapCleanup; kill 0; }'

    # if in debug mode, keep a rolling execution record
    ${(P)debug_option_:-false} && {
        typeset -g VERBOSE=true
        typeset -g QUIET=""
        typeset -ag ROLLING
        TRAPDEBUG () {
            typeset i
            for i in {1..4}
            do
                ROLLING[$i]=${ROLLING[$((i+1))]:-}
            done
            ROLLING[5]=$ZSH_DEBUG_CMD;
        }
    }
    eval 'debugDump () {
            . <(localopts array:)
            if [[ ${(Pt)array:-} == array ]]
            then
                print -l -- ${(P)array}
            elif [[ -n ${1:-'$storage_tree_'} ]]
            then
                typeset array=${array:-${1:-'$storage_tree_'}}
                typeset -a keys; typeset key; typeset -i padding
                keys=(${${(n)${(Pk)array//,/\\000}}//\\000/,})
                padding=${#${(OPk)array//?/#}[1]}
                print
                for key in $keys
                do
                    hangingIndent \
                        --margin 2 \
                        --indent $(( $padding + 3 )) \
                        --text \
                        "${(r.$padding...)key} : ${(P)${:-${array}[$key]}}"
                done
            fi
            if ${TREE:-false} && [[ -n ${'$storage_tree_':-} ]]
            then
                __printTree \
                    --input_array       '$storage_tree_' \
                    --tree_option       TREE \
                    --input_filename    '$input_filename_' \
                    --input_filepath    '$input_filepath_'
            fi
        }'
    eval 'debugLog () {
            typeset dlog='${(P)debug_log_}'; typeset x=$1; shift;
            typeset width=72; print -- "\n:<< \\" >> $dlog;
            typeset sq=${(#):-39}
            print "$sq$x${__::=${(r:$(($width-${#x}))::--:):-}}$sq" >> $dlog;
            print -l -- ${*} >> $dlog; print -- "$x${__}\n" >> $dlog;
        }'
}
__InitializeStorageFunctions () {
    . <(localopts storage_tree_:)
    # makes functions that have a default fallback value to specific named
    # arrays without pre-assigning those array names (again, to avoid implicit
    # use of globals... we're still referencing them but making it as explicit
    # as possible)

    # children ()
    #
    # returns all child records given an index. a missing index returns the
    # top level children for the array
    #
    functions[children]='
            . <(localopts in: of:)
            typeset _a_=${in:-'$storage_tree_'} _i=${of:-}
            print ${(@nuP)${:-${_a_}[(I)${_i:-}${_i:+,}[0-9]##,[^,]##]}%,*}
            '

    # active ()
    #
    # must be called inside a function using this syntax:
    #
    # . <(active recordindex)
    #
    # e.g.
    #
    # . <(active 1,1)
    #
    # . <(active $index)
    #
    # resulting in a *local* associative array
    #     active[*] - containing all values for activated record
    #     active[parent,*] - same for parent of activated record
    #     active[drive,*]  - same for drive  of activated record
    #
    # each of the above array subscript variations also contains
    # a convenience index value, for example $active[index]
    #
    functions[active]='
            typeset A=${2:-'$storage_tree_'}
            typeset a=active
            typeset s=""
            typeset _i=$1
            typeset -a e;
            e=(
            '\''$a\[${s:-}${s:+,}index]=$_i; '\''
            '\''eval \${(k)${A}[(I)$_i,#[^,]##]//(#m)'\''
            '\''*/$a\[${s:-}${s:+,}\${(M)MATCH%%[^,]##}'\''
            '\'']=\${(q-)${A}[\$MATCH]}}'\''
            )
            print "setopt TYPESET_SILENT; typeset $a; unset $a;" 
            _ () { print "typeset -A $a;" ${(ej..)e:#\#*} }
            _; _i=${_i%%,#[^,]}; s=parent; [[ -n ${_i:-} ]] && _ || return 0
            _i=${(M)_i##[0-9]#}; s=drive;  [[ -n ${_i:-} ]] && _ || return 0
            '

    functions[indexIsNoclobber]='
        . <(localopts index: field: array:)
        array=${array:-'$storage_tree_'}
        index=${index:-${1:-}}
        [[ -n ${index:-} ]] || fail "$0 missing index"
        typeset ncfield
        for ncfield in ${=NOCLOBBER[partition]};
        do
            eval '\''(( ${+'\''$array'\''[$index,$ncfield]} )) && return 0'\''
        done
        return 1
        '
}
__InitializeRulesets () {

    typeset  -Ag \
        ANCESTORS \
        CHILDREN \
        CODES \
        CONFLICTS \
        DEFAULTS \
        DESCENDANTS \
        DESCRIPTION \
        EQUIVALENTS \
        FIELDS \
        FSTEST \
        INHERIT \
        ITEMOPTIONS_BOOL \
        ITEMOPTIONS_SCAL \
        MAPPING \
        MULTI \
        NOCLOBBER \
        OPTIONS \
        PARENTS \
        PRESET \
        REQUIRED \
        SIBLINGS \
        VALID \
        VALUES

    # the types of storage devices we know about
    # ORDER IS IMPORTANT. Items to the left are *potential* ancestors of items
    # to the right.
    VALUES[type]="drive partition logical encryption swap filesystem subvolume"

    FSTEST[fstype]="bfs btrfs cramfs ext2 ext3 ext4 ext4dev fat jfs minix
                    msdos reiserfs vfat xfs"
    VALUES[fstype]=${${=${listing::=$(print ${:-=mkfs}.*)}}##$(print =mkfs).}
    typeset -a testfs valuesfs newfs missingfs
    valuesfs=(${=VALUES[fstype]}) testfs=(${=FSTEST[fstype]})
    newfs=(${valuesfs:|testfs})
    missingfs=(${testfs:|valuesfs})
    [[ -n ${newfs:-} ]] && alert "New mkfs support noted: ${newfs}. Your
    system either supports new filesystem types or the mkfs command names
    have changed."
    [[ -n ${missingfs:-} ]] && alert "Expected filesystem support missing:
    ${missingfs}. If you don't plan on using those filesystems, this
    won't matter."

    VALUES[code]=${(uM)${:-$(sgdisk -L)}:#([0-9]|[a-f])(#c4)}
    debugLog fstypes "fstypes present via mkfs: ${(@)VALUES[fstype]}"

    # the fields which are valid for each storage item type
    # with 'common' fields being valid for all types
    # these are checked AFTER inheritance and conversions for final
    # validity, and are use DURING inheritance to determine which
    # type inherits which fields
    VALID=(
    common      "notes auto"
    drive       "devpath ssd"
    encryption  "luksformat luksopen pass label encrypt"
    filesystem  "fstype mountpoint label"
    logical     ""
    partition   "bootable code size partnum new keep replace label uuid"
    subvolume   "mountpoint"
    swap        "label"
    )

    # system environment data may have multiple fields that map to a
    # single storge tree field name. this array also serves as a list
    # with which to match templated partitions to existing partitions
    # in the case of keep/replace partitions (hence some mappings are
    # 1-to-1 and just here to complete the list of possible matches)
    #
    # priority is the order of importance:
    # e.g we want to use shortcodes prior to longcodes
    MAPPING=(
    uuid        uuid
    partnum     partnum
    shortcode   code
    longcode    code
    partlabel   label
    label       label
    size        size
    priority    "partnum size shortcode uuid longcode label"
    )

    # the fields which are required for each storage item type
    # some of these will either be inferred or set as defaults,
    # but this list is used for validity check
    REQUIRED=(
    common      ""
    drive       ""
    encryption  ""
    filesystem  "fstype"
    logical     ""
    partition   "size"
    subvolume   ""
    swap        ""
    )

    # migrated these to logic, may need to move them back here TODO
    DEFAULTS=(
    common      ""
    drive       ""
    encryption  ""
    filesystem  ""
    logical     ""
    partition   ""
    subvolume   ""
    swap        ""
    )

    # Inheritable values
    # inheritance retains the value on the source record (if it is valid)
    # else it claims it from the source. this is only attempted if the
    # field is valid for the record in question.
    # TODO: should not need this now
    INHERIT=(
    up          "ssd bootable replace keep"
    down        "ssd keep"
    any         "device partnum fstype size mountpoint code devpath"
    )

    # values that are invalid on the same entry
    # TODO: implement in validity checks
    CONFLICTS=(
    keep        "replace"
    )

    # values which indicate a noclobber element
    # (partitions to retain or replace in situ)
    NOCLOBBER=(
    partition   "keep replace"
    )

    # the valid child device types for a given device type

    # removing filesystem from valid drive child until add back in
    # code to check siblings during inflation phase
    # drive       "partition filesystem"
    CHILDREN=(
    drive       "partition"
    encryption  "filesystem swap"
    filesystem  "subvolume"
    logical     ""
    partition   "encryption filesystem swap"
    subvolume   "subvolume"
    swap        ""
    )

    # default parent values
    PARENTS=(
    drive       ""
    encryption  "partition"
    filesystem  "partition"
    logical     ""
    partition   "drive"
    subvolume   "filesystem"
    swap        ""
    )

    # multiple siblings of the following type are subsumed by a single parent
    # (when said parent is absent)
    # this needs to be addressed by the make step in inflation
    # TODO: unused - may not be an intuitive solution and currently only
    # required for subvolumes as there is a single top level drive creation
    # during inflation).
    MULTI=(
    drive       ""
    encryption  ""
    filesystem  ""
    logical     ""
    partition   "drive"
    subvolume   "filesystem"
    swap        ""
    )

    # the valid sibling device types for a given device type
    SIBLINGS=(
    drive       "drive"
    encryption  ""
    filesystem  ""
    logical     ""
    partition   "partition"
    subvolume   "subvolume"
    swap        ""
    )

    # compile lists of valid descendants per type
    # (base on CHILDREN and VALUES)
    compileValidDescendants () {
        getChildTypes () {
            typeset child
            for child in ${=CHILDREN[$1]}
            do
                print $child
                [[ $child != $1 ]] && getChildTypes $child
            done
        }
        print ${(u):-$(getChildTypes $1)}
    }
    for type in ${=VALUES[type]}
    do
        DESCENDANTS[$type]=$(compileValidDescendants $type)
    done

    # compile lists of valid ancestors per type
    # (base on CHILDREN and VALUES)
    compileValidAncestors () {
        # use order of values to ensure outer-to-inner order
        getParentTypes () {
            typeset type parent
            typeset -a parents
            # from inner to outer
            for type in ${(Oa)=VALUES[type]}
            do
                if [[ -n ${CHILDREN[$type]:-} && \
                      -n ${(M)${=CHILDREN[$type]}:#$1} ]]
                then
                    parents+=($type)
                fi
            done
            print $parents
            for parent in ${=parents}
            do
                [[ $parent != $1 ]] && getParentTypes $parent
            done
        }
        # from outer to inner
        print ${(Oau):-$(getParentTypes $1)}
    }
    for type in ${=VALUES[type]}
    do
        ANCESTORS[$type]=$(compileValidAncestors $type)
    done

    # options used during filesystem/luks/swap format/mount/open/activate
    OPTIONS=(

    "# mkfs"        "options that will be applied to various mkfs commands
                     based on fstype, ssd"

    mkfs            ''
    mkfs,ssd        ''
    mkfs,btrfs      '--force${label:+ --label ${(q-)label:-}}'
    mkfs,btrfs,ssd  '--metadata single' # see man mkfs.btrfs
    mkfs,vfat       '-F32 ${label:+ -n }${label:-}'

    "# mount"       "options that will be applied to mount command based on
                     fstype, ssd values"

    mount           'defaults,x-mount.mkdir'
    mount,ssd       'noatime'
    mount,btrfs     'compress=lzo,space_cache,autodefrag,inode_cache'
    mount,btrfs,ssd 'ssd,discard'

    "# swap"        "swap and ssd specific options"

    swap            ''
    swap,ssd        '--discard'

    "# LUKS"        "both luks formatting and option options"

    luks,format     ''
    luks,open       ''
    luks,open,ssd   '--allow-discards'

    )

    # --force-password below allows weak passphrases (for testing only)
    if ${FORCE:-false} || ${TEST:-false}; then
        OPTIONS[luks,format]='--force-password'
    fi

    # TODO: all presets at this point will be for partitions, though we can stick
    # fstype, etc. info into them if we want to push out filesystems
    # alternately, preset could be a new type
    # e.g. preset biosboot
    # or   preset --name biosboot
    # i like this less since it's not obvious to the user reading the template
    # that it's a partition
    # better to do:
    # partition --preset biosboot
    # the --preset values should be appended AFTER all other values in the line
    # that way anything else will override the presets
    # e.g.
    # partition --preset biosboot --label 'my custom label'
    # would expand to
    # partition --preset biosboot --label 'my custom label' --size 1M --code ef02
    #   --label 'BIOS Boot Partition'
    # and only the first label would be used. that way user doesnt worry about
    # location of override values. this is essentially how i handles defaults.

    PRESET=(
    biosboot                    "--size 1M
                                 --code ef02
                                 --label 'BIOS Boot Partition'"

    efisys                      "--mountpoint /boot/efi
                                 --size 200M
                                 --code ef00
                                 --label 'EFI System Partition'"

    linuxboot                   "--mountpoint /boot
                                 --size 200M
                                 --code 8300
                                 --label 'Linux Boot Partition'"

    existing-windows-recovery   "--noclobber
                                 --code 2700"

    existing-linux-home         "--mountpoint /boot
                                 --size 200M
                                 --code 8300
                                 --label 'Linux Boot Partition'"
    )
    ITEMOPTIONS_BOOL=(

    bootable        "Identifies the storage item (drive, partition,
                     filesystem) as a bootable device. May not always impact
                     the item initialization."

    encrypt         "Used on storage items that may be children of encryption
                     to imply an encryption entry in the template file
                     without adding it explicitly."

    keep            "Keen an existing partition. The partition may be specified
                     by --partnum (1), --devpath (/dev/sda1), or a matching
                     unique value such as label, code, or even size (assuming
                     and exact match of label or size). If using code to match
                     an existing partition, either the sgdisk short code or
                     the long code version of it may be used. Run $0 --listcodes
                     to list all codes."

    replace         "For partitions, tries to match an existing partition based
                     on partnum, devpath, code, label or size and then creates
                     a replacement command (deletes and then recreates)."

    ssd             "Identifies a drive as an ssd (if no devpath is specified
                     for a device, you will be prompted to select a valid drive
                     from a list and will also be prompted to identify is as
                     either a mechanical or ssd drive)."
    )
    ITEMOPTIONS_SCAL=(

    code            "CODE
                     The partition GUID code as used by sgdisk. Can be either
                     an sgdisk two-byte hex code such as 'ef02', or a full GUID
                     type code such as 'EBD0A0A2-B9E5-4433-87C0-68B6B72699C7'
                     (see 'man sgdisk' and 'sgdisk -L'). Note that this is *not*
                     a UUID."

    devpath         "/DEV/PATH
                     The device path, for instance /dev/sda for a drive,
                     /dev/sda1 for a partition, /dev/mapper/cryptvolume for an
                     open luks device, etc. Not required. If no devpath is
                     specified for a drive, you will be prompted to select a
                     valid drive when the script executes."

    fstype          "FILESYSTEM-NAME
                     Filesystem types that this script knows about. Each fstype
                     has a corresponding 'mkfs.*' command. Known filesystem
                     types on this system include ${(@)VALUES[fstype]}"

    label           "'ItemLabel'
                     A human readable label for a partition, filesystem,
                     encrypted device, etc."

    luksformat      "'OPTIONS LIST'
                     Enclose in single quotes. List of command line options
                     applied by cryptsetup when formatting a new dm-crypt
                     device in LUKS mode. For example:

                     --luksformat '--cipher aes-xts-plain64 --key-size 256'
                     
                     Safe defaults are applied if this is absent."

    luksopen        "'OPTIONS LIST'
                     Enclose in single quotes. List of command line options
                     applied by cryptsetup when opening a new or existing
                     dm-crypt device in LUKS mode. For example:

                     --luksopen '--cipher aes-xts-plain64 --key-size 256'

                     Safe defaults are applied if this is absent."

    mkfsoptions     "'OPTIONS LIST'
                     Enclose in single quotes. List of command line options
                     applied to a filesystem mkfs command when formatting."

    mountoptions    "MOUNT,OPTIONS
                     Comma separated list of options to apply to a specific
                     storage device containing a filesystem when mounting.
                     Generally not required. For example, the default
                     mountoptions value applied to a btrfs filesystem is:

                     '--force\${label:+ --label }\${label:-}'
                     
                     Note that use of other option values is possible by
                     simply using the variable form of the option name (e.g.
                     '\$label' for option '--label'."

    mountpoint      "/MOUNT/POINT
                     The absolute path to the mountpoint for a storage item.
                     If not set, then the item will not be mounted!"

    partitioning    "NOT YET IMPLEMENTED
                     Type of partitioning. Defaults to 'gpt'. Can be set to
                     gpt, mbr, or btrfs."

    partnum         "PARTITION_NUMBER
                     This is automatically assigned but may also be specified
                     manually on noclobber partitions or on partitions you wish
                     to manually control the order/partition number of."

    pass            "PASSPHRASE
                     Passphrase for a encryption item. Insert obvious security
                     warning about saving passphrases in files here."

    preset          "PRESETNAME
                     Use a preset value for the given type. For example, the
                     preset 'boot' for a partition will set the type code,
                     mountpoint, and size to specific values."

    size            "SIZE
                     Size of a partition. May be specified in either sgdisk
                     friendly absolute size format using the following
                     suffixes: kibibytes (K), mebibytes (M), gibibytes (G),
                     tebibytes (T), or pebibytes (P), or may be a percentage
                     value which will use the specified percent of the
                     *available* space on the drive (excluding any partitions
                     preserved using --noclobber) such as '30%'
                     (% IS CURRENTLY UNIMPLEMNTED). You may also
                     enter 'max' as a value to use the maximum available
                     (remaining) free space after all other partitions have
                     been assigned. Using the value 'ram' will similarly set
                     the partition size to match the install system memory,
                     useful for partitions that contain swap devices. Note
                     that if a partition does contain a swap device without
                     a size value assigned to either, a size of 'ram' will be
                     assigned by default."

    uuid            "'UUID'
                     A uuid intended to match an existing partition; better to
                     use another, simpler field such as code, size, label to
                     match existing partitions, but this is here if you really
                     like entering long hex code values (and for internal use)."

    )

#    type            "TYPE
#                     Any of the valid storage device types. Unlike the other
#                     options in the fields list, this is *not* specified with
#                     an extended option style '--' prefix. Rather each line
#                     starts with the type word. Valid types: ${(@)VALUES[type]}"

    # fields that are valid for use. not all valid for all storage types.
    FIELDS[boolean]=${(k)ITEMOPTIONS_BOOL}
    FIELDS[scalar]="${(k)ITEMOPTIONS_SCAL}"

    # partition GUID global type code lookup table
    # (translate from sgdisk two byte codes to full GUID)
    # this is not exhaustive
    # cf http://sourceforge.net/p/gptfdisk/code/ci/master/tree/parttypes.cc
    # cf http://www.freedesktop.org/wiki/Specifications/DiscoverablePartitionsSpec/
    # cf http://www.freedesktop.org/software/systemd/man/systemd-gpt-auto-generator.html
    # cf http://en.wikipedia.org/wiki/GUID_Partition_Table
    # cf http://www.sepago.de/e/nicholas/2012/07/25/windows-recovery-environment-re-explained
    # cf http://technet.microsoft.com/en-us/library/dd744301(v=ws.10).aspx

    CODES=(
    0100,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - FAT-12"
    0400,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - FAT-16 < 32M"
    0600,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - FAT-16"
    0700,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - NTFS (or HPFS)"
    0b00,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - FAT-32"
    0c00,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - FAT-32 LBA"
    0c01,E3C9E316-0B5C-4DB8-817D-F92DF00215AE "Microsoft reserved"
    0e00,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - FAT-16 LBA"
    1100,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - Hidden FAT-12"
    1400,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - Hidden FAT-16 < 32M"
    1600,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - Hidden FAT-16"
    1700,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - Hidden NTFS (or HPFS)"
    1b00,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - Hidden FAT-32"
    1c00,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - Hidden FAT-32 LBA"
    1e00,EBD0A0A2-B9E5-4433-87C0-68B6B72699C7 "Microsoft basic data - Hidden FAT-16 LBA"
    2700,DE94BBA4-06D1-4D40-A16A-BFD50179D6AC "Windows RE"
    8200,0657FD6D-A4AB-43C4-84E5-0933C84B4F4F "Linux swap"
    8300,0FC63DAF-8483-4772-8E79-3D69D8477DE4 "Linux filesystem"
    8301,8DA63339-0007-60C0-C436-083AC8230908 "Linux reserved"
    8302,933AC7E1-2EB4-4F13-B844-0E14E2AEF915 "Linux /home"
    8303,44479540-F297-41B2-9AF7-D131D5F0458A "Linux x86 root (/)"
    8304,4F68BCE3-E8CD-4DB1-96E7-FBCAF984B709 "Linux x86-64 root (/)"
    8305,B921B045-1DF0-41C3-AF44-4C6F280D3FAE "Linux ARM64 root (/)"
    8306,3B8F8425-20E0-4F3B-907F-1A25A76F98E8 "Linux /srv"
    8e00,E6D6D379-F507-44C2-A23C-238F2A3DF928 "Linux LVM"
    ab00,426F6F74-0000-11AA-AA11-00306543ECAC "Apple boot"
    af00,48465300-0000-11AA-AA11-00306543ECAC "Apple HFS/HFS+"
    af01,52414944-0000-11AA-AA11-00306543ECAC "Apple RAID"
    af02,52414944-5F4F-11AA-AA11-00306543ECAC "Apple RAID offline"
    af03,4C616265-6C00-11AA-AA11-00306543ECAC "Apple label"
    af04,5265636F-7665-11AA-AA11-00306543ECAC "AppleTV recovery"
    af05,53746F72-6167-11AA-AA11-00306543ECAC "Apple Core Storage"
    ea00,BC13C2FF-59E6-4262-A352-B275FD6F7172 "Freedesktop BOOT"
    ed00,F4019732-066E-4E12-8273-346C5641494F "Sony system partition"
    ed01,BFBFAFE7-A34F-448A-9A5B-6213EB736C22 "Lenovo system partition"
    ef00,C12A7328-F81F-11D2-BA4B-00A0C93EC93B "EFI System"
    ef01,024DEE41-33E7-11D3-9D69-0008C781F39F "MBR partition scheme"
    ef02,21686148-6449-6E6F-744E-656564454649 "BIOS boot partition"
    fd00,A19D880F-05FC-4D3B-A006-743F0F84911E "Linux RAID"
    )

    # generate short and long code lookup/reverse lookups
    CODES+=(
    ${(k)=CODES//,/ }
    ${(k)=CODES//(#b)(#s)(*),(*)(#e)/$match[2] $match[1]}
    )
    
}
__SourceDebugLog () {
    . <(localopts \
        source_file_:           \
        return_system_data_:    \
        return_fileraw_:        )
    # TODO: implement local to global conversion in function
    if [[ -n ${(P)source_file_:-} ]]
    then
        if [[ -f ${(P)source_file_} ]]
        then
            zsh +n ${(P)source_file_} &>/dev/null || {
                fail "${(P)source_file_} failed syntax check. Check format." }
            . ${(P)source_file_}
            warn "Using a simulated environment sourced using the
                  --debugsource option If the sourced environment differs
                  from the actual environment, resulting script will not
                  be safe to execute on this system."
        else
            fail "Unable to locate debug file '${(P)source_file_}'.
                  Check filename/path."
        fi
    fi
    [[ -n ${(P)return_system_data_:-} ]] \
        && debugCapture $return_system_data_
    [[ -n ${(P)return_fileraw_:-} ]] \
        && debugCapture $return_fileraw_
}
__CaptureEnvironment () {
    # creates an array with keys formatted similarly to:
    # return_array_[/dev/sda1,mountpoint]
    . <(localopts return_array_:)

    typeset -Ag $return_array_
    typeset -A STAGING
    typeset -T lsblk_fields_list lsblk_fields ','
    lsblk_fields=(
        LABEL
        MODEL
        MOUNTPOINT
        NAME
        PARTLABEL
        RM
        RO
        SIZE
        TYPE
        UUID
        VENDOR
        )
    for line in ${"${(@f)$(lsblk -Pp -o $lsblk_fields_list)}"}
    do
        STAGING=(${(0)line//(#m)[[:WORD:]]##=/${(#):-0}${MATCH%=}${(#):-0}})
        typeset devname=${(Q)STAGING[NAME]%% #}
        unset "STAGING[NAME]"
        typeset key="" value=""
        for key in ${(k)STAGING}
        do
            if [[ -n ${${value::=${(Q)STAGING[$key]%% #}}%0} ]]
            then
                eval $return_array_'[$devname,${(L)key}]=$value'
            fi
        done
    done

    # get existing partition codes
    if [[ $USERNAME == root ]]
    then
        # list of available partitions on system
        # (first set all_types, then pull out the partitions)
        typeset -A all_types 
        : ${(AA)all_types::=${(Pkv)${:-${return_array_}[(I)*type]}}}
        typeset -a all_partitions
        all_partitions=(${(k)all_types[(R)part]%,type})
        typeset -a all_drives
        all_drives=(${(k)all_types[(R)disk]%,type})

        typeset longcode short_code
        for partition in $all_partitions
        do
            # if sgdisk chokes on the disk, skip it
            if sgdisk ${partition%%[0-9]#} &>/dev/null
            then
                longcode=${${:-"$(sgdisk -i${(M)partition%%[0-9]#} ${partition%%[0-9]#})"}//(#b)*GUID code: ([^[:space:]]##)*/$match}
                eval $return_array_'[$partition,longcode]=${(u)longcode}'
                [[ -n ${shortcode::=${CODES[$longcode]:-}} ]] && \
                    eval $return_array_'[$partition,shortcode]=${(u)shortcode}'
            fi
        done

        # now get start and end values for each partition
        # (for --replace partitions)
        for drive in $all_drives
        do
            # if sgdisk chokes on the disk, skip it
            if sgdisk ${partition%%[0-9]#} &>/dev/null
            then
        sgdump="$(sgdisk -p /dev/sda)}"
        eval ${${${(@f)sgdump}:#[^[:space:]]*}//(#b)(#s) ##([0-9]##) ##([0-9]##) ##([0-9]##)*/$return_array_+=($drive$match[1],start $match[2] $drive$match[1],end $match[3])}
            fi
        done

    else
        alert "NOT ROOT USER. This script will still execute but cannot read
        the sgdisk code or partition start/end values. This only affects:
        1) --keep or --replace partitions using --code to infer the
        actual current partition
        2) --replace partitions that will need to know the start and
        end values. If you are not using --keep or --replace partitions,
        this will not affect you."
    fi

    debugCapture $_return_array
}
__FileLocate () {

    # takes a filename, relative path, absolute path, or url, returns a local,
    # absolute file path (either discovered or downloaded) with an exit code
    # of 1 for failure. the zsh sublist below first checks for a remote file
    # and downloads it if that is the  case, then tries to just source the
    # file as give (so either in the PWD or an absolute path or a valid
    # relative path), and if that fails, it then looks in the scriptroot and
    # recursive subdirectories for a match, finally returning an exit code 1
    # if it fails.

    . <(localopts \
        original_filepath_: \
        return_filepath_:   \
        tmpdir_:            \
        root_:              \
        debugmode_:         )

    typeset -a r s

    # if no file has been supplied
    if [[ -z ${(P)original_filepath_:-} ]]
    then
        # if we are in debug output mode then dump environment
        if ${(P)debugmode_:-false}
        then
            alert "No input file supplied, saving system environment only due
            to --debug mode being set." 1>&2
            exit 0
        # otherwise show minimal usage
        else
            __Usage --mini
            alert "Storage definition filename, path or URL required.
                        See the ${SCRIPTROOT}/storage-patterns subdirectory."
            exit 0
        fi
    elif [[ ${(P)original_filepath_} =~ "(http|ftp)s?:.*" ]]
    then
         curl -sL "$original_filepath_" \
              -o ${res::=${tmpdir_%/}/${original_filepath_:t}} || res=""
    elif [[ ! -f "${res::=${(P)original_filepath_:a}}" ]]
    then
         [[ -f "${res::=${r[${s[(i)${${(o@)${(@A)s::=${(@)${(fA)r::=$(\
             print -l \
             ${(P)root_}/***/${(P)original_filepath_}(.onOd:A))}//[^\/]/}}}[1]}]:-}]:-}}" ]]\
             || res=""
    fi
    # at this point will have a result if we were able
    # otherwise fail
    if [[ -n "$res" ]]; then
        eval typeset -g $return_filepath_="$res"
        report "Using source file $res"
    else
        fail "Failed to locate file ${(P)original_filepath_}"
    fi
}
__FileRead () {
    . <(localopts \
        source_filepath_: \
        return_array_: )
    typeset -ag $return_array_
    eval $return_array_'=("${(@f)$(< ${(P)source_filepath_})}")'
    debugCapture $return_array_
}
__FileClean () {
    # convert storage definition file from supplied format to one ready for
    # further conversion to array of records. removes all comments, merges
    # escaped newlines, etc. converts types (drive, partition to optargs,
    # records indentation level for later processing.
    . <(localopts source_array_: return_array_: )

    # note that without the noted comment strip :# removal below,
    # we have a problem with files that have trailing comments
    typeset -a e
    typeset counter=${(#):-29}
    e=(
    ': '
    '${(AP)return_array_::='
    '${'
    '${'
    '${'
    '${'
    '${(s:; :j: :)'
    '${'
    '${(@Z+C+)'
    '${(F)'
    '${'$source_array_':#[[:blank:]]#\#*}' '# added a comment strip here'
    '#${'$source_array_'}'                 '# original'
    '//(#b)'
    '(#s)'
    '( #)'
    '/${(l.${#match[1]}..'$counter'.):-}'
    '}}}}'
    '//(#b)'
    '(#s)'
    '('$counter'#)'
    '(*)'
    '/'
    '${match[2]} '
    '--indent '
    '${#match[1]}}'
    '//'$counter'/}'
    '//(#s)'
    '\#*(#e)/}'
    '//(#s)'
    '/--type }}'
    )
    eval ${(j..)e:#\#*}
}
__FileConvertToArray () {
    . <(localopts \
            source_array_:    \
            return_array_:   \
            ruleset_array_fields_:   \
            previous_index: \
            previous_indent:)

    typeset -Ag $return_array_

    # write staging array if this is our first call to the function
    # (treat input as immutable)
    if ! (( ${+previous_index} )); then
        unset STAGING # in case used in other functions clean up if they didn't
        typeset -ag STAGING
        eval 'STAGING=("${(@)'$source_array_'}")'
        source_array_=STAGING
    fi

    typeset -a bool; bool=(${(P)=${:-${ruleset_array_fields_}[boolean]}})
    typeset -a scal; scal=(${(P)=${:-${ruleset_array_fields_}[scalar]}})
    typeset -a opts; opts=(${bool} ${scal})

    typeset index
    typeset -i sibling_index

    while ${${(P)source_array_:+true}:-false}; do # process array line by line

        eval set -- ${(P)${source_array_}[1]};
        . <(localopts ${bool} ${^scal}: indent: type:)

        #typeset leftovers
        #leftovers="${*:-NULL}"

        if (( $indent > ${previous_indent:=$indent} )); then # child, recurse

            $0 --source_array_ $source_array_ \
                --return_array_ $return_array_ \
                --ruleset_array_fields_ $ruleset_array_fields_ \
                --previous_index $index \
                --previous_indent $indent
            
        elif (( $indent == $previous_indent )); then # valid sibling; process

            # generate index path (e.g. 1,2,1) for array subscript
            index=${previous_index:-}${previous_index:+,}$((++sibling_index))

            # warn if anything is left over, but don't fail
            if [[ -n ${leftovers:-} ]]; then

                alert "Unknown option/argument values for item type '$type'
                      encountered while reading storage definition file:
                      ${leftovers} This is non-critical."

                # If the beginning of the leftovers match an option name
                # suggest that the user forgot the -- prefix
                if [[ "${leftovers:-}" =~ (^(${(j:|:)~opts}).*) ]]; then
                    alert "Did you forget the -- prefix to specify the option
                        name?\nIf so, try changing it to: --$*\n" 1>&2
                fi

            fi

            # TODO: re-set optargs and process them here, since
            # we are scraping the o value output of localopts, a
            # really bad way to do this. better to iterate over opts
            eval set -- ${(P)${source_array_}[1]};
            . <(localopts ${bool} ${^scal}: indent: type:)
            typeset leftovers="${@:-}"

            # assign values to storage array (this assigns all of them)
            typeset -a e; e=(
            '${=${:-${(@)^${(@M)${(@k)o##-#}//(#m)(*)/${return_array_}'
            '[${index}${index:+,}${MATCH}]${MATCH:+=}${(q)o[--'
            '${MATCH}]#=}}};}//typesetNULL/typeset }' 
            ); eval ${(ej::)e}

            # strip indent values (could be in a pattern above as well)
            # to normalize test output (indent value compute may change)
            eval 'unset "${:-${return_array_}[$index,indent]}"'

            # remove first item in array since we have assigned it to
            # return_array_
            eval $source_array_'[1]=()';

        else # return from recursion or function
            return 0
        fi
    done

    # remove unrequired indent values
    # (this doesn't need to be eval'd but it was screwing up syntax
    # highlighting otherwise... TODO

}
__InflateStructure () {
    . <(localopts               \
        input_storage_array_:   \
        output_storage_array_:  \
        fields_array_:          \
        values_array_:          \
        ancestors_array_:       \
        children_array_:        \
        descendants_array_:     \
        equivalents_array_:     \
        valid_array_:           )
    typeset storage_array_=$output_storage_array_
    # clone input to output for processing if not identical array names
    if [[ ${input_storage_array_:-} != ${output_storage_array_:-} ]]
    then
        typeset -Ag $storage_array_
        eval $storage_array_'=(${(kvPq-)input_storage_array_})'
    fi
    insertParent () {
        . <(localopts array: index: type:)
        array=${array:-$storage_array_}
        index=${index:-${active[index]:-}}
        [[ -z ${type:-} ]] && fail "type missing in call to $0"
        InflateStructure__InsertGapIndentSingleBranch \
            --array $array --insertion_point $index 
        eval $array'[$index,type]=$type'
        eval $array'[$index,auto]=""'
    }
    insertSibling () {
        . <(localopts array: index: type:)
        array=${array:-$storage_array_}
        index=${index:-${active[index]:-}}
        [[ -z ${type:-} ]] && fail "type missing in call to $0"
        InflateStructure__InsertGapNoIndentSiblings \
            --array $array --insertion_point $index 
        eval $array'[$index,type]=$type'
    }
    isTypeValidForLineage () {
        # is $check the same type as, or a valid relative type of $against?
        typeset origopts; origopts="$@"
        . <(localopts check: against: lineage: nullvalid samevalid)
        [[ -n ${against:-} && -n ${lineage:-} ]] || {
            fail "missing optargs in $0" }
        [[ ${(U)lineage} =~ (ANCESTORS|DESCENDANTS) ]] || {
            fail "bad lineage in $0" }
        if ${nullvalid:-false} && ${samevalid:-false}
        then
            fail "Cannot set both nullvalid and samevalid options for $0"
        fi
        typeset -a valid_list
        valid_list=(${(P)=${:-${(U)lineage}[$against]}:-})
        [[ -n $check ]] || { ${nullvalid:-false} && {
        return 0 } || return 1 }
        [[ $check != $against ]] || { ${samevalid:-} && {
        return 0 } || return 1 }
        [[ -n ${(M)valid_list:#$check} ]] &&  {
        return 0 } || return 1
    }
    # for ancestor loop
    isSameOrDescendantType () {
        isTypeValidForLineage \
            --lineage descendants \
            --samevalid \
            --check "$1" \
            --against "$2"
    }
    isNullOrAncestorType () {
        isTypeValidForLineage \
            --lineage ancestors \
            --nullvalid \
            --check "$1" \
            --against "$2" || return 1
        typeIsNotInAncestralLineageOfIndex \
            $2 $3 && return 0 || return 1
    }
    typeIsNotInAncestralLineageOfIndex () {
        # type is $1, index is $2
        typeset index=${2%%,#[0-9]##}
        while [[ -n ${index:-} ]]
        do
            getTypeByIndex --index $index --result type
            [[ $type != $1 ]] || return 1
            index=${index%%,#[0-9]##}
        done
        return 0
    }
    # for descendant loop
    isSameOrAncestorType () {
        isTypeValidForLineage \
            --lineage ancestors \
            --samevalid \
            --check "$1" \
            --against "$2"
    }
    isNullOrDescendantType () {
        isTypeValidForLineage \
            --lineage descendants \
            --nullvalid \
            --check "$1" \
            --against "$2"
    }
    # equivalence is primarily for filesystem/swap which are
    # of the equivalent level
    isEquivalentType () {
        typeset -a checklist checkvalue; checkvalue=($2)
        checklist=(${(P)=${:-${equivalents_array_}[$1]}:-})
        [[ -n ${checklist:*checkvalue} ]]
    }
    getByIndex () {
        # returns error if value is missing
        # returns non error if value is set even
        # if empty value
        . <(localopts array: index: field: result:)
        [[ -n ${index:-} && -n ${field:-} && -n ${array:-} ]] || {
            fail "bad call to $0 - missing
            ${index:-index }${field:-field }${array:-array}"
        }
        eval '(( ${+'$array'['$index,$field']} )) || { return 1 }'
        [[ -z ${result:-} ]] || {
        eval $result'="${'$array'[$index,$field]}"' }
        return 0
    }
    noteByIndex () {
        . <(localopts array: index: note:)
        [[ -n ${array:-} && -n ${index:-} && -n ${note:-} ]] || \
            fail "bad call to $0"
        eval $array'[$index,notes]+="* ${${=note}}\n"'
        teelog --verbose --category note --color cyan ${=note}
    }
    getTypeByIndex () {
        . <(localopts index: result:)
        [[ -n ${result:-} ]] || {
            fail "bad call to $0 index ${index:-NULL}
                result ${result:-NULL}" }
        [[ -n ${index:-} ]] || return 1
        getByIndex \
            --array $storage_array_ \
            --index $index \
            --field type \
            --result $result
    }
    # tag items with the required ancestor to ensure it is
    # auto generated if not already present. this tag will
    # then bubble up/out to it and be discarded
    tagByIndex () {
        . <(localopts index:)
        typeset record_type
        getTypeByIndex \
            --index $index \
            --result record_type
        for tag_type in ${(P)=${:-${values_array_}[type]}}
        do
            typeset -a type_list
            type_list=(${(P@)=${:-${children_array_}[$tag_type]}})
            if [[ -n ${type_list:-} \
               && -n ${(M)type_list:#$record_type} ]]
            then
                setByIndex \
                    --array $storage_array_ \
                    --index $index \
                    --field $tag_type \
                    --value ''
                return
            fi
        done
    }
    tagLoop () {
        . <(localopts start_at:)
        typeset -a types
        types=(${(P)=${:-${values_array_}[type]}})
        typeset -a children
        children=($(children --in $storage_array_ --of "${start_at:-}"))
        for record_index in $children
        do
            tagByIndex --index $record_index
            $0 --start_at $record_index
        done
    }
    tagLoop
    inflateDrive () {
        . <(localopts storage_array_:)
        [[ -n ${storage_array_:-} ]] || fail "$0 missing storage_array_"
        # insert and indent all items, add drive
        # (if no initial drive present)
        if [[ ${(P)${:-${storage_array_}[1,type]}} == drive ]]
        then
            return 0
        fi
        typeset -A STAGING; STAGING=()
        typeset index
        for index in ${(Pk)storage_array_}
        do
            STAGING[1,$index]=${(P)${:-${storage_array_}[$index]}}
        done
        STAGING[1,type]=drive
        STAGING[1,auto]=""
        eval $storage_array_'=("${(@kv)STAGING}")'
        noteByIndex \
            --array $storage_array_ \
            --index 1 \
            --note "Made top level drive entry."
    }
    inflateDrive --storage_array_ $storage_array_
    inflateDevpaths () {
        . <(localopts storage_array_: start_at:)
        typeset -a children
        children=($(children --in $storage_array_ --of "${start_at:-}"))
        typeset index
        for index in $children
        do
            . <(active $index $storage_array_)
            if [[ -n ${(M)${active[devpath]:-}%%[0-9]##} ]]
            then
                setByIndex \
                    --field partnum \
                    --index ${active[index]:-} \
                    --value ${(M)active[devpath]%%[0-9]##}
                setByIndex \
                    --field devpath \
                    --index ${active[index]:-} \
                    --value ${active[devpath]%%[0-9]##}
            fi
            $0 inflateDevpaths \
                    --storage_array_ $storage_array_ \
                    --start_at $index
        done
    }
    inflateDevpaths --storage_array_ $storage_array_
    inflateLoop () {
        . <(localopts start_at:)
        typeset -a types
        types=(${(P)=${:-${values_array_}[type]}})
        typeset -a children
        children=($(children --in $storage_array_ --of "${start_at:-}"))
        for record_index in $children
        do
            . <(active $record_index $storage_array_)
            typeset record_type
            record_type=${active[type]}
            typeset -a record_fields
            record_fields=(${(k)active})
            typeset record_parent_index=${active[parent,index]:-}
            typeset record_children_indexes="$(\
                children --in $storage_array_ --of $record_index)"
            # inner to outer for ancestors, outer to inner for descendants, thus
            # order of creation is as close to current record type as possible
            typeset -a \
                valid_ancestor_types \
                valid_descendant_types \
                valid_record_fields
            typeset rt=$record_type
            valid_ancestor_types="${(O)${(@)types[1,(i)${rt}]}[1,-2]:-}"
            valid_descendant_types="${${(@)types[${types[(i)$rt]},-1]}[2,-1]:-}"
            valid_record_fields=(${(P)=${:-${valid_array_}[$rt]}})
            # check ancestors and descendants
            typeset lineage make_new_record_test move_field_test
            for lineage in ancestors descendants
            do

                # find the "rightful owner" types of fields which should be
                # moved elsewhere

                [[ $lineage == ancestors ]] && {
                    typeset valid_lineage_types=$valid_ancestor_types }
                [[ $lineage == descendants ]] && {
                    typeset valid_lineage_types=$valid_descendant_types }

                for rightful_owner_type in ${=valid_lineage_types}
                do
                    # no "common" valid array fields, since those are
                    # automatically generated and would provide false
                    # positives
                    typeset -a rightful_owner_fields
                    # rightful_owner_type is added as a pseudo-tag that will
                    # be used to create required parents
                    rightful_owner_fields=(
                    ${(P)=${:-${valid_array_}[$rightful_owner_type]}}
                    $rightful_owner_type)
                    # get fields that could be assigned to new/existing
                    # records in the lineage of this current record. for example
                    # if a filesystem has a --size value, that could (should) be
                    # assigned to a partition, which is a valid type within the
                    # lineage of filesystem.
                    typeset invalid_fields
                    invalid_fields=${record_fields:*rightful_owner_fields}
                    for invalid_field in ${=invalid_fields}
                    do
                        # it's possible that this field is valid for BOTH the
                        # rightful_owner and for the current record type (e.g.
                        # label) so just continue without removing it if that
                        # is the case
                        if [[ -n ${(M)valid_record_fields:#$invalid_field} ]]
                        then
                            # valid for check record but also for current record
                            # so leave it where it is
                            continue
                        fi
                        # MOVE/MAKE CHECK
                        #
                        # the :-"" below ensures that we loop once with a
                        # null value if the list is otherwise empty
                        #for relative_index in ${=relative_list:-""}
                        # NOW: adding a null value always

                        [[ $lineage == ancestors ]] && {
                            typeset relative_list=$record_parent_index }
                        [[ $lineage == descendants ]] && {
                            typeset relative_list=$record_children_indexes }

                        for relative_index in ${=relative_list:-} ''
                        do
                            typeset relative_type=""
                            [[ -z ${relative_index:-} ]] || {
                                getTypeByIndex \
                                    --index $relative_index \
                                    --result relative_type    }

                            # Move Field
                            # -----------------------------------------------
                            # Try to move the invalid_field to an existing
                            # parent or child, or move it to an invalid parent
                            # or child that can then pass it onwards to the
                            # final legitimate record (either existing or to
                            # be created).

                            [[ $lineage == ancestors ]] && {
                                typeset move_field_test=isSameOrDescendantType }
                            [[ $lineage == descendants ]] && {
                                typeset move_field_test=isSameOrAncestorType }

                            if $move_field_test \
                                "${relative_type:-}" \
                                $rightful_owner_type
                            then
                                # if field exists on target record, skip
                                getByIndex \
                                    --array $storage_array_ \
                                    --index $relative_index \
                                    --field $invalid_field && continue
                                typeset record_field_value
                                getByIndex \
                                    --array $storage_array_ \
                                    --index $record_index \
                                    --field $invalid_field \
                                    --result record_field_value
                                unsetByIndex \
                                    --array $storage_array_ \
                                    --index $record_index \
                                    --field $invalid_field
                                setByIndex \
                                    --array $storage_array_ \
                                    --index $relative_index \
                                    --field $invalid_field \
                                    --value "$record_field_value"
                                noteByIndex \
                                    --array $storage_array_ \
                                    --index $record_index \
                                    --note "Moved field $invalid_field from this
                                            $record_type to ${lineage%s}
                                            $relative_type (if not valid for
                                            this field, will sort outwards from
                                            this record to valid record or will
                                            be removed)"
                                return 1
                            fi

                            # Make Record For Field
                            # -----------------------------------------------
                            # if there is no parent/child or the current
                            # parent/child is a valid ancestor/descendant of the
                            # potential new record type (to be inserted between
                            # the current record and its current parent/child)
                            # then make a new parent or child (depending on
                            # current ancestor/descendant loop)
                            # the 'new_relative_index' is only used in this test
                            # for ancestor lineage test
                            typeset \
                                new_relative_index \
                                new_relative_cmd \
                                make_new_record_test=isNullOrDescendantType
                            if [[ $lineage == ancestors ]]
                            then
                                typeset make_new_record_test=isNullOrAncestorType
                                new_relative_index=$record_index
                                new_relative_cmd=insertParent
                            elif [[ $lineage == descendants ]]
                            then
                                typeset make_new_record_test=isNullOrDescendantType
                                new_relative_index=${relative_index:-$record_index,1}
                                if [[ -n ${relative_index:-} ]]
                                then
                                    new_relative_cmd=insertParent
                                else
                                    #new_relative_cmd=insertParent #insertSibling
                                    new_relative_cmd=insertSibling
                                fi
                            fi
                            if $make_new_record_test \
                                "${relative_type:-}" \
                                $rightful_owner_type \
                                $new_relative_index
                            then
                            $new_relative_cmd \
                                    --type $rightful_owner_type \
                                    --array $storage_array_ \
                                    --index $new_relative_index || {
                                        fail "$new_relative_cmd failed with:\ntype:
                                              $rightful_owner_type\nindex:
                                              $new_relative_index" }
                                tagByIndex --index $new_relative_index

                                [[ $lineage == ancestors ]] && {
                                    typeset relation=parent }
                                [[ $lineage == descendants ]] && {
                                    typeset relation=child }

                                noteByIndex \
                                    --array $storage_array_ \
                                    --index $new_relative_index \
                                    --note "Created $rightful_owner_type
                                            $relation for $record_type due to
                                            $invalid_field field."
                                return 1
                            fi
                        done
                    done
                done
            done
            $0 --start_at $record_index
        done
    }
    while ! inflateLoop; do :; done
}
InflateStructure__InsertGapNoIndentSiblings () {
    # given an insertion point such as 1,2 - list all siblings (1,1 1,2 1,3)
    # and return the maximum value of the sibling index component (3 in this
    # example) work backwards from the max value sibling to the insertion
    # point sibling index (2 in this example), shuffling them down by
    # incrementing their value finally leaving an open gap at the top.
    . <(localopts input_array: insertion_point:)
    typeset -a e
    e=(
    '${'
    '${'
    '${(MOn)'           '# Match part of %%[0-9]##,type (below) reverse order'
    $input_array
    '[(I)'              '# Search through keys of array'
    '${insertion_point' '# ...for keys matching the insert point'
    '//(#b)'            '# ...modify that insert point search string'
    '([0-9]##)(#e)'     '# ...by replacing the last numeric index component'
    '/[0-9]##}'         '# ...and making it a regex to match its siblings'
    ',type]'            '# ...add a type string to match key record field'
    '%%[0-9]##,type}'   '# final index,type value from results (M) above'
    '%%,type}'          '# and trim the ,type part off'
    '[1]}'              '# take first of (reverse sorted) sibling indexes'
    )
    ip_sib_id=${(M)insertion_point%%[0-9]##}
    ip_head=${insertion_point%%[0-9]##}
    sibscheck=${(P)${:-${input_array}[(I)ip_head,[0-9]}##,type]}    
    if [[ -n ${sibscheck} ]]
    then
        max_sib_id=${(ej..)e:#\#*} 
        sibs=(${ip_head}{$max_sib_id..$ip_sib_id})
        for sib_index in $sibs
        do
            new_sib_index=${sib_index//(#b)([0-9]##)(#e)/$(($match+1))}
            for index in ${(P)${:-${input_array}[(I)$sib_index,*]}}
            do
                new_index=$new_sib_index${index##$sib_index}
                eval $input_array'[$new_index]=${(P)${:-${input_array}[$index]}}'
                unset "${input_array}[$index]"
            done
        done
    else
        # return if there were no siblings
        return 0
    fi
}
InflateStructure__InsertGapIndentSingleBranch () {
    # inserts a gap at a specific (existing) record and indents the
    # original record and children to be new children of new "gap" record
    # (a new record can then be written at that gap point)
    . <(localopts input_array: insertion_point:)
    typeset -a new_index
    typeset -a make_insertion_point_descendants
    make_insertion_point_descendants=(
    '${'
    '${(On)'            '# make this reversed so as not to overwrite existing'
    '${(Pk)'            '# reference to array, returning keys only'
    '${:-'              '# dummy parameter expansion'
    '${input_array}'    '# ...consisting of value (name) of input_array'
    '[(I)'              '# ...and a search subscript'
    '$insertion_point'  '# ...returning both self...'
    ',*'                '# ...and children of the insertion_point'
    ']}'
    '//,/\\000'         '# swap out commas for null bytes for numerical sort'
    '}'
    '}'
    '//\\000/,'         '# having sorted, replace the commas'
    '}'
    )
    typeset index
    for index in ${(ej..)make_insertion_point_descendants:#\#*}
    do
        # this newindex expansion fails inside the following assignment
        # subscript. why? for now assigning to a paramt outside the subscript
        # (specifically, the comment stripping fails in the subscript, even
        # when not using the eval/input array reference)
        # note - i assume this is because i need to add @ for array output
        # as a parameter flag, TODO
        new_index=${index//(#b)(#s)($insertion_point)(*)/$match[1],1$match[2]}
        eval $input_array'[$new_index]=${(P)${:-${input_array}[$index]}}'
        unset "${input_array}[$index]"
    done
}
__ScrubStructures () {
    . <(localopts \
            storage_array_: \
            verbose_array_: \
            values_array_:  )
    typeset record
    typeset -a scrubfields
    scrubfields=(encrypt ${(P)=${:-${values_array_}[type]}})
    ! ${(P)verbose_array_:-} && scrubfields+=(notes)
    for record in ${(P)${:-${storage_array_}[(I)*,(${(j:|:)scrubfields})]}}
    do
        eval 'unset "'$storage_array_'[$record]"'
    done
}
__ValidateStructures () {

    . <(localopts \
            storage_array_:   \
            children_array_:\
            siblings_array_:\
            required_array_:\
            valid_array_:   \
            pindex:         )

    typeset -a children
    children=($(children --in $storage_array_ --of "${pindex:-}"))

    for record in $children; do

        . <(active $record)

        # run parent-child validity checks if we have a parent value
        if [[ -n ${pindex:-} ]]; then

            # check that this item's parent has this type as a valid child
            if ! valueInListOrListAbsent \
                "${:-${children_array_}[${active[parent,type]:-}]}" ${active[type]}
            then

                fail "Type '${active[type]}' invalid child of type
                        '${active[parent,type]}'";

            fi

            # check for subvolume parent fstype, making it btrfs if missing
            if [[ ${active[type]} == subvolume \
                && ${active[parent,type]:-} == filesystem \
                && ${active[parent,fstype]} != btrfs ]]
            then

                fail "Filesystem parent of subvolume must have --fstype
                        btrfs, but is currently ${active[parent,fstype]}."

            fi

        fi

        # check that this item has no prohibited siblings
        for sibling in $(getOtherSiblings $record)
        do
            typeset stype=${(P)${:-${storage_array_}[$sibling,type]}:-}
            valueInListOrListAbsent \
                "${:-${siblings_array_}[${active[type]}]}" $stype || {
                fail "'${active[type]}' is not a valid sibling of type 
                          '${active[parent,type]}'" }
        done

        # get list of actual fields
        typeset fields_actual
        fields_actual=${(P)${:-${storage_array_}[(I)$record,[^0-9]##]}#$record,}

        # check that all existing fields for this type are valid
        typeset -a validfields
        validfields=(
            ${(P)=${:-${valid_array_}[common]}}
            ${(P)=${:-${valid_array_}[${active[type]}]}}
            )
        for field in ${${=fields_actual}:#type}
        do
                #"${valid_array_}[${active[type]}]" $field || {
            valueInList validfields $field || {
                fail "'$field' is not a valid field of type 
                          '${active[type]}'. Run this script with the
                          --usage option to review valid options types"
                        }
        done

        # check that all required fields for this type exist
        if ! activeIsNoclobber; then
            for field in ${(P)=${:-${required_array_}[${active[type]}]}:-}
            do
                valueInList \
                    fields_actual $field || {
                    fail "Required field '$field' for type '${active[type]}'
                            is missing!"
                        }
            done
        fi

        # if type is filesystem and !noclobber, must have fstype so that we
        # can make it. otherwise no fstype is required as we're just going
        # to mount and can at least give it a go without fstype
        if [[ ${active[type]} == filesystem && -z ${active[fstype]:-} ]] \
            && ! activeIsNoclobber; then

            fail "Filesystem is missing --fstype option. This would be ok
                    if the filesystem had the --noclobber option (for an
                    existing filesystem that you wish to mount) but in this
                    case it looks like you want to make a new filesystem, so
                    we need to know what type."

        fi

        # every partition that is !noclobber must have a size at this point
        if [[ ${active[type]} == partition && -z ${active[size]:-} ]] \
            && ! activeIsNoclobber; then

            fail "Partition is missing --size option. This would be ok if
                    the partition had the --noclobber option (for an
                    existing partition that you wish to mount) but in this
                    case it looks like you want to make a new partition, so
                    we need to know what size"

        fi

        # every partition that is !noclobber must have a size at this point
        if [[ ${active[type]} == partition \
            && -z ${active[devpath]:-} \
            && -z ${active[partnum]:-} ]] \
            && { activeIsNoclobber }; then

            alert "Partition entry tagged with 
            --${active[keep]+keep}${active[replace]+replace} (partition
            entry ${record##*,} under drive ${record%%,*}) has no --devpath
            or --partnum; will try to match an existing system partition using
            other values (code, label, size if available) or through user query."

        fi

        # validate size field value
        if [[ -n ${active[size]:-} ]] && ! activeIsNoclobber
        then

            if ! [[ ${(U)active[size]} =~ ^([0-9]*[KMGTP%]|RAM|MAX)$ ]]
            then
                fail "Improperly formatted --size value. ${active[type]}
                --size value set to ${active[size]} but must be a value similar
                to: '200M', '100G', '50%', 'max' or 'ram'. Valid unit suffixes
                include: 'K' (kibibytes), 'M' (mebibytes), 'G' (gibibytes), 'T'
                (tebibytes), or 'P' pebibytes, or may be '%' for percentage
                values. Use 'max' to indicate that the partition should fill
                the maximum available free space on the drive after all other
                partitions have been assigned. Use ram to set the value to
                the amount of installed system ram."
            fi

        fi

        # if item has both a devpath and partnum (unnecessary) then they
        # must not conflict
        if [[ -n ${active[devpath]:-} && -n ${active[partnum]:-} ]]
        then
            if [[ ${(M)active[devpath]%%[0-9]#} != ${active[partnum]} ]]
            then
                fail "${active[type]} has both a --devpath and --partnum
                value set and they don't match. Only one is necessary,
                generally partnum (the drive devpath can be specified on a
                parent 'drive' entry and the partnum will be applied to it)."
            fi

        fi

        # recurse into children of this child
        $0  --storage_array_    $storage_array_ \
            --children_array_   $children_array_\
            --siblings_array_   $siblings_array_\
            --valid_array_      $valid_array_   \
            --required_array_   $required_array_\
            --pindex            $record

    done
}
__AssignDrives () {
    # ensure each drive has a devpath, sourced from (in order):
    #   * --drives command line list of drive device paths
    #   * template existing values
    #   * queried values (defaulting to first choice if --yes) 
    . <(localopts               \
            drives_override_:   \
            system_data_:       \
            storage_tree_:      \
            yes_to_all_:        \
            skip_system_data_:  )
    typeset -a command_line_drives
    command_line_drives=(${(P)drives_override_})
    typeset drive
    for drive in $(children)
    do
        . <(active $drive)
        if [[ $active[type] != drive ]]
        then
            fail "Critical: top level element is not of type 'drive'."
        fi
        typeset new_devpath=""
        # -------------------------------------------------------------
        # *) HAVE command line drives
        # -------------------------------------------------------------
        # these take precedence and override everything else, so we
        # use them (though perhaps we should note or query if they are
        # note valid)
        # -------------------------------------------------------------
        if [[ -n ${command_line_drives:-} ]]
        then
            # use top of --drives stack
            new_devpath=${command_line_drives[1]:-}
            [[ -n ${new_devpath:-} ]] || return 0
            command_line_drives[1]=()
        # -------------------------------------------------------------
        # *) NO command line drives
        # *) TEMPLATE devpath value is present
        # *) IS EITHER:
        #    *) VALID devpath (not installable OR missing==invalid)
        #    *) or TRUE skip_system_data
        # -------------------------------------------------------------
        # query for devpath
        # -------------------------------------------------------------
        elif [[ -n ${active[devpath]:-} ]] && \
             (  ${(P)skip_system_data_:-false} ||
                assignDrives__queryForDrive \
                    --system_data_ $system_data_    \
                    --test_valid $active[devpath]   \
                    --yes_to_all ${(P)yes_to_all_:-false} )
        then
            noteByIndex                 \
                --array $storage_tree_  \
                --index $active[index]  \
                --note "Retaining existing devpath value
                        ($active[devpath])"
        # -------------------------------------------------------------
        # *) NO command line drives
        # *) TEMPLATE devpath is either missing or INVALID
        # *) FALSE skip_system_data
        # -------------------------------------------------------------
        # query for devpath
        # -------------------------------------------------------------
        elif ! ${(P)skip_system_data_:-false}
        then
            # get a new drive entry (interactive unless
            # --yes is set as a command line option)
            assignDrives__queryForDrive             \
                --system_data_ $system_data_        \
                --selected_devpath_ new_devpath     \
                --yes_to_all ${(P)yes_to_all_:-false}
        # -------------------------------------------------------------
        # *) NO command line drives
        # *) TEMPLATE devpath is either missing or INVALID
        # *) TRUE skip_system_data
        # -------------------------------------------------------------
        # untenable... could query for manually entered path but better
        # to inform user and have explicit choices made via
        # recommendations in msg below
        # -------------------------------------------------------------
        else
            fail "Missing devpath for drive $drive and the
            --${(L)skip_system_data_} option is set, so no query
            will be run to select a new drive. Either edit the
            template to add a --devpath value, use the
            --drives command line option to list drive
            devpaths you wish to use, or run again without the
            --${(L)skip_system_data_} command line option."
        fi
        # if we came out of the conditional with a new devpath,
        # assign it to this and all other occurences
        if [[ -n ${new_devpath:-} && 
              ${new_devpath:-} != ${active[devpath]:-} ]]
        then
            assignDrives__replaceAllDevpathOccurences   \
                --storage_tree_  $storage_tree_         \
                --old_devpath    "${active[devpath]:-}" \
                --new_devpath    $new_devpath           \
                --drive_index    $drive
        elif [[ -z ${new_devpath:-} && -z ${active[devpath]:-} ]]
        then
            fail "$0 - Unexpected drive assignment condition. Failed to
            acquire a device path value for drive $drive."
        fi
    done
}
assignDrives__replaceAllDevpathOccurences () {
    . <(localopts           \
            storage_tree_:  \
            old_devpath:    \
            new_devpath:    \
            drive_index:    )
    # old devpath may be empty, in which case new devpath is assigned
    # and no scan of other old devpath instances is performed
    if [[ -z ${old_devpath:-} ]]
    then
        setByIndex --index $drive_index --field devpath --value $new_devpath
        return 0
    fi
    typeset -a old_devpath_matches
    typeset -A drive_children
    drive_children=(${(Pkv)${:-${storage_tree_}[(I)$drive_index*]}})
    old_devpath_matches=(${(k)drive_children[(R)$old_devpath*]})
    typeset -a e
    e=(
    ${storage_tree_}        '# from storage tree...'
    '[$old_devpath_field]'  '# find the matching devpath element from loop'
    '='                     '# and assign...'
    '$new_devpath'          '# the new devpath value...'
    '${' ${storage_tree_}
    '[$old_devpath_field]#' '# plus the TRIMMED old devpath...'
    '$old_devpath}'   '# trimmed to remove the old devpath
                               value and retain any partnum component.'
    )
    typeset old_devpath_field
    for old_devpath_field in $old_devpath_matches
    do
        eval ${(j::)e:#\#*}
    done
    # add a note, collapsing the match results to unique indexes
    typeset old_devpath_record
    for old_devpath_record_index in ${(u)${old_devpath_matches%%,*}}
    do
        noteByIndex \
            --array $storage_tree_ \
            --index $old_devpath_record_index \
            --note "Replaced old devpath value $old_devpath with
                    $new_devpath"
    done
}
assignDrives__queryForDrive () {
    . <(localopts               \
            system_data_:       \
            selected_devpath_:  \
            yes_to_all:         \
            test_valid:         )
    # confirm that something else created the result var so that we're not
    # making a global here
    setReturnValue () {
        [[ -z ${selected_devpath_:-} ]] || eval $selected_devpath_'=$1' }
    setAsSelected  () { eval ${system_data_}'[$1,selected]=true' }
    # will allow a non valid drive to be selected unless valid_only is true
    typeset -A all_types all_mountpoints drive_filter_arrays
    : ${(AA)all_types::=${(Pkv)${:-${system_data_}[(I)*type]}}}
    : ${(AA)all_mountpoints::=${(Pkv)${:-${system_data_}[(I)*mountpoint]}}}
    drive_filter_arrays=(
    1,all_drives        '${(k)all_types[(R)disk]%,type}'
    2,selected_drives   '${(Pk)${:-${system_data_}[(I)*selected]}%,selected}'
    3,unselected_drives '${all_drives:|selected_drives}'
    4,mounted_drives    '${(k)all_mountpoints%[0-9]##,mountpoint}'
    5,unavail_drives    '$mounted_drives $selected_drives'
    6,ext_drives        '${(Pk)${:-${system_data_}[(I)*rm]}%,rm}'
    7,avail_drives      '${all_drives:|unavail_drives}'
    8,int_avail_drives  '${avail_drives:|ext_drives}'
    )
    typeset array
    for array in ${(ok)drive_filter_arrays}
    do
        typeset -a ${array#[0-9]##,}
        eval ${array#[0-9]##,}'=('${drive_filter_arrays[$array]}')'
    done
    if [[ -n ${test_valid:-} ]]
    then
        if [[ -n ${avail_drives:-} &&
              -n ${(M)avail_drives:#$test_valid} ]]
        then
            () { setReturnValue $1; setAsSelected $1;
                 report "Retaining drive path set in template $drive path: $1"
            } ${test_valid}
            return 0
        else
            return 1
        fi
    fi
    [[ -n ${selected_devpath_:-} && 
          ${(Pt)selected_devpath_:-} == scalar* ]] || {
          fail "$0: missing or wrong type for option selected_devpath" }
    # if yes_to_all is set then we return the first available internal
    # drive. this may be incorrect but it's the "best guess" and the
    # user can still review the results.
    if ${yes_to_all:-false}
    then
        if [[ -n ${int_avail_drives} ]]
        then
            () { setReturnValue $1; setAsSelected $1;
                 report "Automatically selected drive $drive path: $1"
            } ${int_avail_drives[1]}
            return 0
        elif [[ -n ${avail_drives} ]]
        then
            () { setReturnValue $1; setAsSelected $1;
                 report "Automatically selected drive $drive path: $1"
            } ${avail_drives[1]}
            return 0
        else
            # no available drives: we'll drop out of the conditional here
            # and use the failure message in the following conditional
        fi
    fi
    # query user for drive selection
    if [[ -n ${avail_drives} ]]
    then
        typeset eraser
        eraser="${:-${(l.$COLUMNS...):-}${(pl.$COLUMNS..\b.):-}}"
        typeset msg="Drive $drive device selection"
        display "\n$msg\n${msg//?/-}"
        display "Select from list of available (unmounted, unselected) drives:"
        print 1>&2 
        typeset -i ad=0
        typeset adrive
        for adrive in $avail_drives
        do
            print -n "$((++ad)) $adrive (" 1>&2
            [[ -n ${(P)${:-${system_data_}[$adrive,rm]}:-} ]] \
                && print -n "external" 1>&2 || print -n "internal" 1>&2
            print -n " ${(P)${:-${system_data_}[$adrive,size]}:-} " 1>&2
            print "${(P)${:-${system_data_}[$adrive,model]}:-})" 1>&2
        done
        print "\nq: Quit\n" 1>&2
        typeset confirm=""
        while [[ -z ${(M)${confirm:-n}:#y} ]]; do
            print -n "${${msg:-}//?/\b}$eraser" 1>&2
            msg="Enter selection number (1"
            [[ $ad -gt 1 ]] && msg+="-$ad"; msg+="/q) "
            print -n "$msg" 1>&2
            typeset r="0"
            # accept digits 1-$i if $ad<10 (eg 1-3), otherwise digits 0-9
            while [[ -z ${(M)${r}:#[q$((ad>9?0:1))-$((ad>9?9:$ad))]#} ]]
            do
                read -ks r
            done
            if [[ ${(L)r} == q ]]
            then
                print "${${msg:-}//?/\b}${eraser}User selected quit.\n" 1>&2
                exit
            fi
            print -n "${${msg:-}//?/\b}" 1>&2
            print -n "$eraser" 1>&2
            print -n "${msg::=${avail_drives[$r]} - correct? (y/n) }" 1>&2
            read -qs confirm && print 1>&2 || print -n "\b" 1>&2
        done
        () { setReturnValue $1; setAsSelected $1 } ${avail_drives[$r]}
        report "Manually selected drive $drive path: ${(P)selected_devpath_}"
    else
        fail "No unavailable (unmounted, not previously selected) drives
        are available on this system. If you wish to use an existing
        mounted drive you can unmount it and run again or run $SCRIPTNAME
        again with the --skip option to skip checking the current system
        state. If you use --skip, you must assign drives either within
        the storage template file using --devpath or with the --drives
        command line option."
    fi
}
__AssignPartitions () {
    # ensure each partition has a partnum, sourced from (in order):
    #   * existing partnum from template, if valid (fail if not?)
    #   * matching partition based on values
    #     (for noclobber keep/replace partitions)
    #   * first available partition number (based on max available
    #     partition number, taking into consideration noclobber and skip)
    #   * queried values (defaulting to first choice if --yes) if not
    #     skipping
    . <(localopts               \
            system_mapping_:    \
            drives_override_:   \
            system_data_:       \
            storage_tree_:      \
            yes_to_all_:        \
            skip_system_data_:  )
    typeset -a earmarked_partitions
    typeset drive
    for drive in $(children)
    do
        AssignPartitions__IdentifyExistingPartitions\
            --system_mapping_   $system_mapping_    \
            --storage_tree_     $storage_tree_      \
            --system_data_      $system_data_       \
            --yes_to_all_       $yes_to_all_        \
            --skip_system_data_ $skip_system_data_  \
            --on_drive          $drive
        # enumerated could include both noclobber and new that
        # already had a partnum assigned
        typeset -aU earmarked
        earmarked=()
        AssignPartitions__EarmarkEnumeratedPartitions\
            --storage_tree_     $storage_tree_      \
            --on_drive          $drive              \
            --earmarked_        earmarked
        # we earmark all system partitions UP TO the last
        # so this is equivalent to "find maximum current partnum
        # and earmark from 1..maximum". We could look into more
        # complex partition removal, sorting, reassignment later
        # but that's getting tricky and best left to the user
        # to arrange manually
        if [[ -n ${(P)${:-${storage_tree_}[(I)$drive*(keep|replace)]}} ]]
        then
            AssignPartitions__EarmarkSystemPartitions   \
                --system_data_      $system_data_       \
                --storage_tree_     $storage_tree_      \
                --on_drive          $drive              \
                --earmarked_        earmarked
        fi
        AssignPartitions__EnumerateRemainingPartitions  \
            --storage_tree_     $storage_tree_          \
            --on_drive          $drive                  \
            --earmarked_        earmarked
        AssignPartitions__ReorderPartitionRecords       \
            --storage_tree_     $storage_tree_          \
            --on_drive          $drive
        AssignPartitions__CheckForPartitionGaps         \
            --system_data_      $system_data_           \
            --storage_tree_     $storage_tree_          \
            --on_drive          $drive
    done
}
AssignPartitions__IdentifyExistingPartitions () {
    . <(localopts \
            system_mapping_:    \
            storage_tree_:      \
            system_data_:       \
            yes_to_all_:        \
            skip_system_data_:  \
            on_drive:           )
    typeset partition
    for partition in $(children --of $on_drive)
    do
        . <(active $partition)
        if [[ $active[type] == partition ]] \
           && activeIsNoclobber \
           && ! ${(P)skip_system_data_:-false}
        then
            typeset matched_partnum=""
            if ! AssignPartitions_InferPartition \
                --system_mapping_ $system_mapping_ \
                --partition $partition \
                --yes_to_all_ $yes_to_all_ \
                --storage_tree_ $storage_tree_ \
                --system_data_ $system_data_ \
                --return_matched_partnum_ matched_partnum
            then
                # inference failed; query instead
                AssignPartitions_QueryForPartition \
                    --partition $partition \
                    --yes_to_all_ $yes_to_all_ \
                    --storage_tree_ $storage_tree_ \
                    --system_data_ $system_data_ \
                    --return_matched_partnum_ matched_partnum
            fi
            if [[ -n ${matched_partnum:-} ]]
            then
                # only update keep partitions with full system data, otherwise
                # just update size
                AssignPartitions_UpdateFromExisting \
                    --replace ${${replace[keep]+true}:-false} \
                    --system_mapping_ $system_mapping_ \
                    --partition $partition \
                    --drive $active[drive,devpath] \
                    --matched_partnum $matched_partnum \
                    --storage_tree_ $storage_tree_ \
                    --system_data_ $system_data_
            else
                fail "Unable to identify an existing system partition for
                template partitition tagged with
                --${active[keep]+keep}${active[replace]+replace}. Either
                supply more data (existing partnum, matching code, label,
                size, etc.) or check the existing system to confirm you
                have entered data that indeed matches the system configuration."
            fi
        fi
    done
}
AssignPartitions_InferPartition () {
    . <(localopts \
            system_mapping_:    \
            storage_tree_:      \
            system_data_:       \
            yes_to_all_:        \
            partition:          \
            return_matched_partnum_:  )
        . <(active $partition)
        [[ $active[type] == partition ]] || { 
            fail "$0 index received not of type partition" }
        typeset -a fields
        fields=(${(P)=${:-${system_mapping_}[priority]}})
        typeset field
        for field in $fields
        do
            if [[ -n ${active[$field]:-} ]]
            then
                # match existing
                typeset -A candidates; candidates=()
                typeset -a previously_matched; previously_matched=()
                typeset -a matched; matched=()
                typeset value=$active[$field]
                typeset drive=$active[drive,devpath]
                candidates=(${(PkvL)${:-${system_data_}[(I)$drive*$field]}})
                previously_matched=(${${(Pk)${:-${system_data_}[(I)$drive*,matched]}#$drive}%%,*})
                matched=(${${(k)candidates[(R)${(L)value}]#$drive}%%,*})
                matched=(${(M)matched:|previously_matched})
                if (( ${#matched} == 1 ))
                then
                    eval ${system_data_}'[$drive$matched,matched]="matched $partition by $field";'
                    eval $return_matched_partnum_'=$matched'
                    reportInferred "matched partition tagged with
                    --${active[keep]+keep}${active[replace]+replace} to
                    $active[drive,devpath]$matched by $field value ($active[$field])"
                    return 0
                # else if there is more than one match, we assign it here
                # with a warning that this is sloppy
                elif (( ${#matched} > 1 )) && ${(P)yes_to_all_:-false}
                then
                    eval ${system_data_}'[$drive$matched[1],matched]="matched $partition by $field";'
                    eval $return_matched_partnum_'=$matched[1]'
                    warn "MULTIPLE MATCH: matched partition
                    tagged with --${active[keep]+keep}${active[replace]+replace}
                    to $active[drive,devpath]$matched[1] by $field value
                    ($active[$field]). This was the FIRST of multiple matching
                    existing partitions and MAY NOT BE THE PARTITION YOU WANTED.
                    Please review results carefully or run again without
                    --${(L)yes_to_all}."
                    return 0
                    
                fi
            fi
        done
        # got here without matching
        return 1
}
AssignPartitions_UpdateFromExisting () {
    . <(localopts \
            replace:        \
            system_mapping_:\
            partition:      \
            drive:          \
            matched_partnum:\
            storage_tree_:  \
            system_data_:   )

    typeset -a fields updated
    updated=(NULL) # conditional below chokes on match without some (NULL) value here
    if ${replace:-false}
    then
        fields=(size)
    else
        # prioritize shortcode and partlabel TODO: should do this in ruleset
        fields=(${(P)=${:-${system_mapping_}[priority]}})
    fi
    for field in $fields
    do
        # if we have a system value and we haven't written to the mapped
        # equivalent already then write to it regardless of existing values
        typeset v="" f=""
        if [[ -n ${v::=${(P)${:-${system_data_}[$drive$matched_partnum,$field]}:-}} ]] \
           && [[ -z ${(M)updated:#${f::=${(P)${:-${system_mapping_}[$field]}}}} ]]
        then
            eval $storage_tree_'[$partition,$f]=$v'
            updated+=($f)
        fi
    done
    # update partnum as well
    eval $storage_tree_'[$partition,partnum]=$matched_partnum'
}
AssignPartitions_QueryForPartition () { 
    . <(localopts \
            partition:      \
            yes_to_all_:    \
            storage_tree_:  \
            system_data_:   \
            return_matched_partnum_:  )
    . <(active $partition)
    typeset -A candidates
    typeset -a all_partitions
    typeset -a previously_matched
    typeset -a available_partitions
    typeset -a matched; matched=()
    typeset drive=$active[drive,devpath]
    candidates=(${(PkvL)${:-${system_data_}[(I)$drive*type]}})
    all_partitions=(${(ko)candidates[(R)part]%,type})
    previously_matched=(${(Pk)${:-${system_data_}[(I)$drive*,matched]}%,matched})
    available_partitions=(${(M)all_partitions:|previously_matched})

    if (( ${#available_partitions} == 1 )) && ${(P)yes_to_all_:-false}
    then
        typeset auto_pn=${available_partitions[1]#$drive}
        warn "Automatically selected partition $drive$auto_pn for partition
        tagged with --${active[keep]+keep}${active[replace]+replace}
        as it was the only available partition on drive $drive and the
        --${(L)yes_to_all_} option was set. THIS MAY NOT BE WHAT YOU INTENDED."
        eval $return_matched_partnum_'=$auto_pn'
        return 0
    elif (( ${#available_partitions} > 1 )) && ${(P)yes_to_all_:-false}
    then
        fail "Multiple partitions are available for assignment to the
        partition tagged with --${active[keep]+keep}${active[replace]+replace}
        but the --${(L)yes_to_all_} option is set so no interactive query will
        be run. Rerun without this option or change your template."
    elif [[ -n ${available_partitions} ]]
    then
        typeset eraser
        eraser="${:-${(l.$COLUMNS...):-}${(pl.$COLUMNS..\b.):-}}"
        typeset msg="Partition device selection:"
        display "$msg\n${msg//?/-}"
        display "template entry details:\n${(@q-)"${(@kv)active[(I)([^,]##)~(notes|type|index)]}"}"
        display "Select from list of available partitions:"
        print 1>&2 
        typeset -i ap=0
        typeset apart
        typeset -a selectable; selectable=()
        for apart in $available_partitions
        do
            print -n "${ap::=${(M)apart%%[0-9]#}} $apart (" 1>&2
            print -n "SIZE:${(P)${:-${system_data_}[$apart,size]}:-} " 1>&2
            print -n "CODE:${(P)${:-${system_data_}[$apart,shortcode]}:-}" 1>&2
            print -n "${(P)${:-${system_data_}[$apart,partlabel]}:+ PARTLABEL:}" 1>&2
            print -n "${(Pq-)${:-${system_data_}[$apart,partlabel]}:-}" 1>&2
            print -n "${(P)${:-${system_data_}[$apart,label]}:+ LABEL}" 1>&2
            print -n "${(Pq-)${:-${system_data_}[$apart,label]}:-}" 1>&2
            print ")" 1>&2
            selectable+=($ap)
        done
        print "\nq: Quit\n" 1>&2
        typeset confirm=""
        while [[ -z ${(M)${confirm:-n}:#y} ]]; do
            print -n "${${msg:-}//?/\b}$eraser" 1>&2
            msg="Enter selection number (1"
            [[ $ap -gt 1 ]] && msg+="-$ap"; msg+="/q) "
            print -n "$msg" 1>&2
            typeset r="0"
            # accept digits 1-$i if $ap<10 (eg 1-3), otherwise digits 0-9
            while [[ -z ${(M)${r}:#[q$((ap>9?0:1))-$((ap>9?9:$ap))]#} ]]
            do
                read -ks r
            done
            if [[ ${(L)r} == q ]]
            then
                print "${${msg:-}//?/\b}${eraser}User selected quit.\n" 1>&2
                exit
            fi
            [[ -n ${(M)selectable:#$r} ]] || { print -n "\b" 1>&2; continue }
            print -n "${${msg:-}//?/\b}" 1>&2
            print -n "$eraser" 1>&2
            print -n "${msg::=$drive$r - correct? (y/n) }" 1>&2
            read -qs confirm && print 1>&2 || print -n "\b" 1>&2
        done
        report "Manually selected partition $drive$r"
        eval $return_matched_partnum_'=$r'
        return 0
    else
        fail "No unavailable (unmounted, not previously selected) partitions
        are available on drive $drive of this system. If you wish to use an
        existing mounted drive or partition you can unmount it and run again
        or run this script again with the --skip option to skip checking the
        current system state. If you use --skip, you must assign drives either
        within the storage template file using --devpath or with the --drives
        command line option."
    fi
    # shouldn't get here!
    fail "Unknown condition in $0"
}
AssignPartitions__EarmarkEnumeratedPartitions () {
    . <(localopts storage_tree_: on_drive: earmarked_:)
    typeset partition
    for partition in $(children --of $on_drive)
    do
        . <(active $partition)
        if [[ $active[type] == partition ]] \
           && [[ -n ${active[partnum]:-} ]]
        then
            eval $earmarked_'+=($active[partnum])'
        fi
    done
}
AssignPartitions__EarmarkSystemPartitions () {
    . <(localopts storage_tree_: system_data_: on_drive: earmarked_:)
    typeset -A candidates
    typeset drivepath=${(P)${:-${storage_tree_}[$on_drive,devpath]}}
    candidates=(${(PkvL)${:-${system_data_}[(I)$drivepath*type]}})
    eval $earmarked_'+=(${${(ko)candidates[(R)part]%,type}#$drivepath})'
}
AssignPartitions__EnumerateRemainingPartitions () {
    . <(localopts storage_tree_: on_drive: earmarked_:)
    typeset -i seq=${${(@PO)${:-${earmarked_}}}[1]}
    typeset partition
    # non max value
    for partition in $(children --of $on_drive)
    do
        . <(active $partition)
        if [[ $active[type] == partition ]] \
           && [[ -z ${active[partnum]:-} ]] \
           && [[ ${active[size]:-} != max ]]
        then
            eval $storage_tree_'[$partition,partnum]=$((++seq))'
        fi
    done
    # max value
    typeset max=0
    for partition in $(children --of $on_drive)
    do
        . <(active $partition)
        if [[ $active[type] == partition ]] \
           && [[ -z ${active[partnum]:-} ]] \
           && [[ ${active[size]:-} == max ]]
        then
            eval $storage_tree_'[$partition,partnum]=$((++seq))'
            max+=1
        elif [[ $active[type] == partition ]] \
           && [[ -z ${active[partnum]:-} ]]
        then
            fail "Unexpected condition: max/non-max enumeration complete but
            there is a remaining non-max (fixed size) partition with no
            partition number!"
        fi
    done
    if (( max > 1 ))
    then
        fail "Unexpected condition: Multiple max size partitions found!"
    fi
}
AssignPartitions__ReorderPartitionRecords () {
    . <(localopts storage_tree_: on_drive:)

    sortPartitions () {
        . <(localopts on_drive:)
        typeset -A partnums
        # get all entries with partnums (thus all numbered partitions)
        partnums=(${(kv)STORAGE[(I)$on_drive,[0-9]##,partnum]})
        # move partitions to temp record namespace
        for partition in ${(k)partnums%,partnum}
        do
            eval ${(k)STORAGE[(I)$partition,*]//(#m)*/STORAGE[TEMP,$MATCH]=${(q-)STORAGE[$MATCH]}; unset \"STORAGE[$MATCH]\"; }
        done
        # move partitions back to actual namespace in new order
        for partition in ${(k)partnums%,partnum}
        do
            # get new index of this partition's partnum from sorted list
            typeset newindex=${partition%%[0-9]#}${${(@nv)partnums}[(i)$partnums[$partition,partnum]]}
            eval ${(k)STORAGE[(I)TEMP,$partition,*]//(#b)(TEMP,)($partition)(,*)/STORAGE[$newindex$match[3]]=${(q-)STORAGE[TEMP,${match[2]}${match[3]}]}; }
        done
        # remove the temp values
        eval ${(k)STORAGE[(I)TEMP,*]//(#m)*/unset \"STORAGE[$MATCH]\"; }
    }
    typeset drive; typeset -a drives; drives=($(children))
    for drive in $drives; do sortPartitions --on_drive $drive; done
}
AssignPartitions__CheckForPartitionGaps () {
    . <(localopts system_data_: storage_tree_: on_drive:)
    typeset -A candidates
    typeset -a system_partitions
    typeset -a storage_partitions
    typeset -aU combined_partitions
    typeset drivepath=${(P)${:-${storage_tree_}[$on_drive,devpath]}}
    candidates=(${(PkvL)${:-${system_data_}[(I)$drivepath*type]}})
    system_partitions=(${${(ko)candidates[(R)part]%,type}#$drivepath})
    storage_partitions=(${(Pv)${:-${storage_tree_}[(I)$on_drive*partnum]}})
    combined_partitions=($system_partitions $storage_partitions)
    typeset max_part=${${(On)combined_partitions}[1]}
    typeset -i _i
    for _i in {1..$max_part}
    do
        [[ -n ${(M)combined_partitions:#$_i} ]] || {
        warn "Drive $drivepath has a partition gap at partition index $_i.
              Consider whether you can resort partitions to address this
              (see 'man sgdisk' for more information)."
    }
    done
}
__printTree () {

    . <(localopts \
            input_array:    \
            start_at:       \
            leader:         \
            input_filename: \
            input_filepath: \
            tree_option:    )

    ${(P)tree_option:-} || return 0

    typeset indentpercent=2 softtab=4
    typeset indent=$(( indentpercent*$COLUMNS/100 ))
    typeset _i=${(l.$indent...):-}
    typeset _ii="$_i$_i"

    typeset columns=$(($COLUMNS)) # wrap columns
    typeset width=$indent # tree line width
    typeset gap=0   # gap for readability

    typeset w=${(l.$width..─.):-}
    typeset b=${(l.$width...):-}
    typeset x=${(l.$gap...):-}
    typeset t="├─$w"
    typeset l="└─$w"
    typeset m="│ $b"
    typeset s="  $b"
    typeset c

    typeset -A colorcodes
    colorcodes=(
    drive       white
    partition   green
    filesystem  blue
    subvolume   blue
    encryption  magenta
    swap        cyan
    logical     orange
    )

    # print intro
    print
    print "${_i}${COLOR[white]:-}Source filename: ${(P)input_filename}"
    print "${_i}Source filepath: ${(P)input_filepath}"
    print
    print "${_i}${COLOR[default]:-}Items in [BRACKETS] have been automatically inferred.\n"
    if ! ${COLOROFF:-false}
    then
        print "${_i}Partitions in ${COLOR[red]}RED${COLOR[default]} are to be replaced due to --replace"
        print "${_i}Partitions in ${COLOR[yellow]}YELLOW${COLOR[default]} are to be retained due to --keep"
        print "${_i}Partitions in ${COLOR[green]}GREEN${COLOR[default]} are to be newly created\n"
    fi

    buildTree () {

        . <(localopts start_at: leader:)

        typeset -a children;
        children=($(children --of "${start_at:-}"))
        typeset add line1 line2 line firstline
        typeset -a wrapped

        for record in $children; do

            . <(active $record)

            # if this isn't last child, use a T, otherwise an L
            # and similarly add/don't add a continuation line
            if [[ $record != ${children[-1]} ]];
            then
                line1="$_ii${leader:+$x}${leader:-}${leader:+$t}"
                add=$m$x
            else
                line1="$_ii${leader:+$x}${leader:-}${leader:+$l}"
                add=$s$x
            fi
            if (( ${+active[auto]} )); then
                active[type]="[${active[type]}]"
            fi
            if (( ${+active[keep]} )); then
                line2="${x}${COLOR[yellow]:-}${active[type]}${COLOR[default]:-} "
            elif (( ${+active[replace]} )); then
                line2="${x}${COLOR[red]:-}${active[type]}${COLOR[default]:-} "
            else
                line2="${x}${active[type]} "
            fi

            # print continuation line if not initial line
            [[ $record != 1 ]] && print "$_ii$x${leader:-}$m"

            typeset -a e_linebuilder
            e_linebuilder=(
            '${line1}'
            '${line2}'
            '${'
                '${(k)active}' '# all active keys for item'
                '//'
                    '(#b)'
                    '(*)' '# use entirekey value in replacement'
                '/'
                    '$match' '# print the key value'
                    '${active['
                        '${match}' '# an equals sign for visual unity'
                    ']:+=}'        '# but only if it is a non boolean'
                    '${active[${match}]:+' '# only output value if not empty'
                    '${(q-)active[${match}]:-}}' '# so booleans output clean'
            '}'
            )
            typeset -a e_colorcoder
            e_colorcoder=(
            '${line_head'
            '//(#b)(#s)'
            '([^[:alnum:]\[]#)'
            '(\[#${typecode}\]#)'
            '/${match[1]}'
            '${COLOR[${colorcodes[$typecode]}]:-}'
            '${match[2]}${COLOR[default]:-}'
            '}'
            )

            # remove keys we don't want
            typeset auto=${${active[auto]+true}:-false}
            typeset type=${active[type]}
            typeset -a remove
            remove=(index auto inferred notes type ${(k)active[(I)(parent|drive)*]})
            for key in $remove
            do
                unset "active[$key]"
            done


            # add all keys
            line=${(ej..)e_linebuilder:#\#*}

            # wrap lines with leaders
            typeset line_head="" line_tail=""
            typeset -a treeoutput; treeoutput=()
            firstline=true
            while [[ -n ${line} ]]
            do
                # check if there are children and modify continuation lines
                [[ -n ${STORAGE[$record,1,type]:-} ]] && c=$m || c=$s

                # add appropriate leader to nested line, only if not first loop
                [[ -n $line_head ]] && {
                line="${_ii}$x${leader:-}${add}$c${(l.$((${#type}-$width-1))...):-}$line"
                }

                # wrap off the current item value, then take the first line
                wrapped=(${(f)${:-"$(print ${line} | fold -s -w $columns)"}})
                line_head=${wrapped[1]}

                # trim the remainder
                line="${(p)${line[$((${#line_head}+1)),-1]## #}//\\n/}"

                # add highlight colors if first line
                $firstline && {
                for typecode in ${(k)colorcodes}
                do
                    line_head=${(ej..)e_colorcoder:#\#*}
                done
                firstline=false
                }

                # print output
                print "$line_head"

            done

            # recursively handle children, modifying the leader
            $0 --start_at $record --leader "${leader:-}${add}"
        done
    }

    buildTree

    # extra line only at very end of output
    [[ -z ${start_at:-} ]] && print \\n
}
__genPayload () {

    . <(localopts input_array: outputvar: sourcefile: infilename: mountroot: multipass: comments_option: warning_option: ignore_env:)

    # prepare arrays
    typeset -ag $outputvar
    typeset width=60
    typeset __="# ${(r:$(($width-2))::--:):-}"

    # output script header
    eval $outputvar'+=(
    "#!/usr/bin/env zsh"
    "$__\n# Storage initialization commmands\n$__"
    "# turn off comments in this output with the following option"
    "# \"$SCRIPTNAME --${(L)comments_option}\"\n$__\n#"
    "# SOURCE FILE - ${(P)infilename}"
    "# read from: ${(P)sourcefile}\n$__"
    ${:-\# }${(f)^"$(< ${(P)sourcefile})"}
    )'

    # script reports/warnings, etc.
    if ${VERBOSE:-false} && ! ${(P)comments_option:-false}
    then
        eval $outputvar'+=( "#\n$__" ${(f)^"$(reportLog)"})'
    fi

    ${(P)warning_option:-false} || {
    typeset warn
    warn="WARNING - hide this with "
    warn+="\"$SCRIPTNAME --${(L)warning_option}\" or \"$SCRIPTNAME -${(U)warning_option:0:1}\""
    ${(P)comments_option:-false} && {
    eval $outputvar'+=(":\n: $warn")' }
    eval $outputvar'+=(
    "\n\n$__\n# $warn\n$__"
    "cat 1>&2 << \\\\\\"
    "--WARNING--"
    "WARNING:\nReview this script prior to running it."
    "Unrecoverable changes may be made to this system.\n"
    "Do you wish to continue? (y/n)\n"
    "--WARNING--"
    "read -qs || exit; print"
    )'
    ${(P)comments_option:-false} && { eval $outputvar'+=(":")' }
    }

    typeset -A section_header
    section_header=(
    partitions  "# Drive formatting and partition structures"
    encryption  "# Encryption"
    filesystem  "# Filesystem creation"
    swap        "# Swap configuration"
    logical     "# Logical volume preparation"
    mount       "# Mount filesystems & create subvolumes"
    )

    sectionHeader () {
        if [[ -n ${section_header[$1]:-} ]]
        then
            eval $outputvar'+=("\n\n$section_header[$1]\n$__")'
            unset "section_header[$1]"
        fi
    }

    genPartitions --ignore_env $ignore_env
    genEncryption --multipass $multipass
    genSwap
    genFilesystem
    genMounts

}
__printPayload () {
    . <(localopts input_array: comments_option:)
    payload="$(print -l -- ${(P)input_array})"
    print 1>&2
    ${(P)comments_option:-false} && { 
    print -l -- ${${(@f)payload}//(#s)\#([^!]|(#e))*/}
    } || print -l -- "${(@)payload}"
}
__Usage () {

    . <(localopts readme mini advanced listcodes)

    typeset marginpercent=2 softtab=4
    typeset margin=$(( marginpercent*$COLUMNS/100 ))
    typeset wrap=$COLUMNS
    typeset __="${(r:$COLUMNS::--:):-}"

    usageHighlight () {
        typeset -g _LL
        . <(localopts indent:)
        typeset s=${COLOR[default,bold]:-} b=${COLOR[blue]:-} d=${COLOR[default]:-}
        # check initial, non indent leading character of last line
        typeset c="${${_LL:-}[$((i+2))]##[[:blank:]]#}"
        (( ${(M)#${(Q)${@}}## #} > (i+2) )) && [[ -z $c ]] && {
        print -- "$b${@}$d"; return }
        # if last line wasn't empty, then this isn't eligible for highlight
        [[ -n $c ]] && { print -- "${_LL::=${@}}"; return }
        typeset -a e
        e=(
        '${${@'                 '# expand all values passed to this function'
        '//(#b)'                '# FIRST search/replace with backreferences on'
        '(#s)'                  '# from start of string'
        '('                     '# for a pattern...'
            '${(l.${indent:-0}...):-}'  '# starting with a number of spaces
                                           equal to the indent integer value'
            '[^:[:space:]]##:'          '# followed by one or more non space
                                           characters and then a colon'
        ')'
        '(*)(#e)'               '# then match the remainder of the line to
                                   match[2] (to end of the string)'
        '/'                     '# replace with...'
        '$s'                    '# default color, bold'
        '$match[1]'             '# the part of the line up to the colon'
        '$d'                    '# default color, no bold'
        '$match[2]'             '# the rest of the line'
        '}'                     '# end of FIRST search/replace'
        '//(#b)'                '# SECOND search/replace with backreferences on'
        '(#s)'                  '# from start of string'
        '([^:]##:[[:blank:]]#)' '# $match one or more non colons, then a colon and maybe a blank'
        '(#e)'                  '# ... to the end of the line'
        '/$s$match$d}'          '# replace with the match, made bold, then back to non bold'
        )
        print -- ${_LL::=${(ej::)e:#\#*}}
    }

    # different highlighting for readme format, along with fixed margin and wrap values
    ${readme:-false} && {
    margin=0; wrap=80
    usageHighlight () {
        . <(localopts indent: mini)
        typeset i=${indent:-0}
        typeset line="$@"
        (( ${(M)#${(Q)line}## #} > (i+2) )) && {
        print -- "${line}"; return }
        typeset c="${${_LL:-}[$((i+2))]##[[:blank:]]#}"
        [[ -n $c ]] && { print -- "${_LL::=${@}}"; return }
        typeset -a e
        e=(
        '${'
        '${'
        'line'
        '//(#b)(#s)([^#:[:space:]]##:) #([^[:blank:]]##*)(#e)/**${match[1]}**${${match[2]## #}:+ }${match[2]## #}}'
        '//(#b)(#s)([^#:]##:[[:blank:]]#)(#e)/### $match}'
        )
        print -- ${_LL::=${(ej::)e:#\#*}}
    }}

    # section heading
    sectionHeading () {
        typeset heading
        ${readme:-false} && {
        print "\n## ${(C)${(L)@}}\n"
        } || {
            smartWrap --indent $margin ${(U)@} --output heading
            print -- "\n${COLOR[magenta]:-}${__}${COLOR[default]:-}"
            print -- "${COLOR[magenta]:-}$heading${COLOR[default]:-}"
            print -- "${COLOR[magenta]:-}${__}${COLOR[default]:-}\n"
        }
    }

    # section subheading
    subHeading () {
        typeset subheading
        ${readme:-false} && {
        print "\n### ${(C)${(L)@}}\n"
        } || {
            smartWrap --indent $margin ${(U)@} --output subheading
            print \\n
            print -l -- ${COLOR[magenta]:-}${^subheading}${COLOR[default]:-}
            print -- ${COLOR[magenta]:-}${(l.$margin...):-}${${(O)${${subheading## #}%% #}//?/-}[1][margin,-1]}${COLOR[default]:-}\\n
        }
    }
    # list codes
    () {
        ${listcodes:-false} || return 0
        typeset key
        typeset h hh h1=SHORT h2=LONGCODE h3=DESCRIPTION
        h="$h1 ${(r.${(vc)#CODES[(i)????]}...)h2} $h3"
        hh="${h1//?/-} ${(r.${(vc)#CODES[(i)????]}..-.):-}"
        print "\n$h\n$hh" ${${(Ov)CODES[(I)????,*]//?/-}[1]}
        for key in ${(k)CODES[(I)????]}
        do
            print -n "${(r.${#h1}...)key} " 1>&2
            print -n "$CODES[$key] " 1>&2
            print "$CODES[$key,$CODES[$key]]" 1>&2
        done
        print "\nSee also 'man sgdisk'\n"
        exit
    }
    # minimal usage
    miniUsage () {
        print "\\n  usage: $SCRIPTNAME [templatename]" 1>&2
        print 1>&2
        typeset -A minimal_opts
        minimal_opts=(
        ${(kv)OPTS_BOOL}
        ${(kv)OPTS_ARGS}
        )

        typeset opt_indent=$(( ${#${(kO@)minimal_opts//?/#}[1]}+7))
        typeset l=${(r.$margin...):-} print=:

        typeset -a optarrays
        optarrays=(${OPTARRAYS:#${~advanced:-*_ALT*}})
        typeset case
        for optset in $optarrays
        do
            [[ $optset =~ _ALT ]] && case=U || case=L
            for opt in ${(okP)optset}
            do
                eval 'typeset optflags="-${('$case')opt:0:1}, --${(L)opt}"'
                typeset -a optval
                optval=("${(@)${(fP)${:-${optset}[$opt]}}## #}")
                typeset optargs optdesc
                if [[ $optset =~ ARGS ]]
                then
                    optargs="${optval[1]}"
                    optdesc="${optval[2]}"
                else
                    optargs=""
                    optdesc="${optval[1]}"
                fi
                print -- "  $optflags $optargs\n      ${optdesc}" 1>&2
            done
        done
        print "\n  For more details and advanced options:\n" 1>&2
        print "      '$SCRIPTNAME --advanced'" 1>&2
        print "      '$SCRIPTNAME --usage | less'" 1>&2
        print "      '$SCRIPTNAME --coloroff --usage | less'\n" 1>&2
        return 0
    }
    ${mini:-false} && { miniUsage; return 0 }

    # general usage (from header at top of script)
    () {
        ${README:-false} && print "# $SCRIPTNAME\n\n" || \
            sectionHeading "$SCRIPTNAME - General Usage"
        smartWrap $SUMMARY \
            --output WRAPPED --indent $margin --wrap $wrap --padding $margin
        for line in ""${^WRAPPED}
        do
            usageHighlight --indent $margin "$line"
        done
        print
    }

    # optargs usage (automatically generated from OPTS_* arrays)
    () {
        sectionHeading "Command Line Options"
        typeset -A allopts
        allopts=(
        ${(kv)OPTS_BOOL}
        ${(kv)OPTS_BOOL_ALT}
        ${(kv)OPTS_ARGS}
        ${(kv)OPTS_ARGS_ALT}
        )

        typeset opt_indent=$(( ${#${(kO@)allopts//?/#}[1]}+7))
        typeset l=${(r.$margin...):-} print=:

        for optset in OPTS_BOOL OPTS_BOOL_ALT OPTS_ARGS OPTS_ARGS_ALT
        do
            for opt in ${(okP)optset}
            do
                if [[ $optset =~ ALT ]]
                then
                    typeset optflags="-${(U)opt:0:1}, --${(L)opt}"
                else
                    typeset optflags="-${(L)opt:0:1}, --${(L)opt}"
                fi
                typeset -a optval
                optval=("${(@)${(fP)${:-${optset}[$opt]}}## #}")
                typeset optargs optdesc
                if [[ $optset =~ ARGS ]]
                then
                    optargs="${optval[1]}"
                    optdesc="${optval[2,-1]}"
                else
                    optargs=""
                    optdesc="${optval}"
                fi
                #smartWrap $optline  --output optline --indent $margin \
                #    --wrap $wrap --padding $margin
                if ${README:-false}; then
                    smartWrap \
                        --margin $margin \
                        --wrap $wrap \
                        "\`$optflags $optargs\`\\\n"
                    smartWrap "${optdesc}" \
                        --wrap $wrap
                else
                    smartWrap \
                        --margin $margin \
                        --wrap $wrap \
                        "${fg_bold[default]:-}$optflags${COLOR[default]:-}"\
                        "$optargs\\\n"
                    smartWrap "${optdesc}" \
                        --indent $((m+softtab)) --wrap $wrap --padding $margin
                fi
                print

            done
        done
    }

    # storage file definition
    () {
        sectionHeading "Storage File Definition Overview"

        subHeading "Storage Definition File - Valid Item Options (Fields)"
        shrinkWrap --margin $margin "These are the options (fields) that are
            acceptable for each of the storage types. The types listed are
            the only valid types (drive, partition, etc.)."
        for t in ${=VALUES[type]}; do
            smartWrap --margin $margin \
                "\\n* \`${t}:\` ${VALID[$t]:-Not yet implemented}"
        done

        subHeading "Storage Definition File - Field Descriptions"
        for optset in ITEMOPTIONS_BOOL ITEMOPTIONS_SCAL
        do
            for opt in ${(okP)optset}
            do
                typeset optflags="--${(L)opt}"
                typeset -a optval
                optval=("${(@)${(fP)${:-${optset}[$opt]}}## #}")
                typeset optargs optdesc
                if [[ $optset =~ SCAL ]]
                then
                    optargs="${optval[1]}"
                    optdesc="${optval[2,-1]}"
                else
                    optargs=""
                    optdesc="${optval}"
                fi
                #smartWrap $optline  --output optline --indent $margin \
                #    --wrap $wrap --padding $margin
                if ${README:-false}; then
                    smartWrap \
                        --margin $margin \
                        --wrap $wrap \
                        "\`$optflags $optargs\`\\\n"
                    smartWrap "${optdesc}" \
                        --wrap $wrap
                else
                    smartWrap \
                        --margin $margin \
                        --wrap $wrap \
                        "${fg_bold[default]:-}$optflags${COLOR[default]:-}"\
                        "$optargs\\\n"
                    smartWrap "${optdesc}" \
                        --indent $((m+softtab)) --wrap $wrap --padding $margin
                fi
                print
            done
        done
    }

}
__ListTemplates () {
    print "\nReading template files from $SCRIPTROOT/templates\n" 1>&2
    print -l -- $SCRIPTROOT/templates/***~(*README)(#q.:t) 1>&2
    print 1>&2
}
__AlphaWarning () {
    # If not me, or root, or on another system, warn unless
    # user adds --alpha option

    # me on dev machine
    typeset DEVSTRING=es@skylla
    
    ${ALPHA:-false} || [[ -z ${${:-$USERNAME@$HOST}:#$DEVSTRING} ]] && return 0
    __Usage --mini
    warn "Hello, not me: this is hard core alpha code.
          Please read the readme and maybe glance at the sgdisk manual
          to understand the final script output. Then run $SCRIPTNAME
          again with the '--alpha' or '-A' option to skip this warning.
          Or just skip the reading and run it now, but be sensible."
    exit 1
}

:<< \
------------------------------------------------------------------------------
__inferMissingElements subsidiary functions

each of these assumes the scope of __inferMissingElements  and must be called
from within it (i.e. there is no explicit parameter option passing on these)
------------------------------------------------------------------------------
isSet () {
    # return true if value is set, even if non null
    # takes parameter name, not value, natch
    eval '(( ${+'${1}'} )) && return 0 || return 1'
}
descendantOrSelfIsNoclobber () {
    . <(localopts index: field: array:)
    array=${array:-STORAGE}
    index=${index:-${1:-}}
    [[ -n ${index:-} ]] || fail "$0 missing index"
    typeset ncfield
    for ncfield in ${=NOCLOBBER[partition]};
    do
        eval '[[ -n ${+'$array'[(I)$index,*$ncfield]} ]] && return 0'
    done
    return 1
}
ancestorOrSelfIsNoclobber () {
    . <(localopts index: field: array:)
    array=${array:-STORAGE}
    index=${index:-${1:-}}
    [[ -n ${index:-} ]] || fail "$0 missing index"
    typeset ncfield
    while [[ -n ${index:-} ]]
    do
        for ncfield in ${=NOCLOBBER[partition]};
        do
            eval '(( ${+'$array'[$index,$ncfield]} )) && return 0'
        done
        index=${index%%,#[0-9]#}
    done
    return 1
}
activeIsNoclobber () {
    indexIsNoclobber --index ${active[index]}
}
activeIsSet () {
    isSet "active[$1]"
}
setActive () {
    setByIndex --index ${active[index]:-} --field $1 --value "${2:-}"
}
unsetActive () {
    unsetByIndex --index ${active[index]:-} --field $1
}
setByIndex () {
    . <(localopts index: field: array: value:)
    array=${array:-STORAGE}
    [[ -n ${index:-} && -n ${field:-} ]] || \
        fail "bad call to $0 with missing
            ${index:-index} ${field:-field}"
    eval $array'[$index,$field]="${value:-}"'
}
unsetByIndex () {
    . <(localopts index: field: array:)
    array=${array:-STORAGE}
    index=${index:-${active[index]:-}}
    field=${field:-${1:-}}
    unset "${array}[$index,$field]"
}
ancestorGetMatch () {
    # returns first ancestor index that matches required field
    # returns full index: 1,1,fieldname
    . <(localopts index: field: array:)
    array=${array:-STORAGE}
    index=${index:-${active[index]:-}}
    field=${field:-${1:-}}
    typeset -a index_components
    index_components=(${(s:,:)index[1,-2]})
    while [[ -n $index_components ]]
    do
        isSet "${array}[${(j:,:)index_components},$field]" \
            && print "${(j:,:)index_components},$field"
        index_components[-1]=()
    done
    return 1
}
getOtherSiblings () {
    # returns the list of siblings of the submitted index
    # exluding the index itself
    . <(localopts index: array:)
    array=${array:-STORAGE}
    index=${index:-${1:-${active[index]:-}}}
    typeset -a ia; ia=($index) # index as array for pattern exclusion
    typeset pi=${${index%,[0-9]}:#$index} # parent index, 1,1->1 1->null
    print -- ${${(Pk)${:-${array}[(I)${pi:-}${pi:+,}[0-9]#,type]}%%,type}:|ia}
}

:<< \
------------------------------------------------------------------------------
__genPayload subsidiary functions

each of these assumes the scope of __genPayload and must be called from
within it (i.e. there is no explicit parameter option passing on these)
------------------------------------------------------------------------------
genPartitions () {

    . <(localopts start_at: ignore_env:)

    typeset -a children
    children=($(children --of "${start_at:-}"))

    for record in $children; do

        . <(active $record)

        if [[ ${active[type]} == drive ]]
        then
            
            sectionHeader partitions

            # is noclobber
            if descendantOrSelfIsNoclobber --index $record
            then
                typeset ncvalues
                ncvalues="${:-'--${^=NOCLOBBER[partition]}'}"
                eval $outputvar'+=(
                "\n\n# DRIVE - ${active[devpath]}\n$__"
                "# DRIVE CONTENTS PRESERVED (no drive wipe performed) due to"
                "# $ncvalues having been set on partition entries"
                )'

            # has no noclobber settings
            else

                msg1="# backup existing partition table"
                msg2="# erase everything on drive!"
                msg3="# nuke from orbit, just to be sure"
                msg4="# create new gpt structure"
                eval $outputvar'+=(
                "backupdir=\$(mktemp --tmpdir=/tmp -d part-backup-XXX)"
                "backupfile=\"\$backupdir/${active[devpath]//\//_}_backup\""
                "sgdisk --backup=\$backupdir $msg1"
                "print \"Partition table backed up to \$backupdir\" 1>&2"
                "sgdisk --zap-all ${active[devpath]} $msg3" 
                "sgdisk --mbrtogpt --clear ${active[devpath]} $msg4"
                )'

            fi
        fi

        if [[ ${active[type]} == partition ]] && activeIsSet replace
        then

            ${(P)ignore_env:-false} && fail "Cannot process --replace
            partitions while --$ignore_env is set."
            if [[ -n ${SYSTEM:-} && -n ${SYSTEM[${active[devpath]},start]:-} ]]
            then
                msg=""
                [[ $USERNAME == root ]] || msg=", most probably
                because you are not running as root"
                fail "Partition entry with --replace partition has
                been assigned to $devpath, but we are unable to
                read and start/end partition data$msg."
            fi
            sgdisk_msg="# Delete existing partition, recreate it"
            sgdisk_cmd="sgdisk"
            sgdisk_cmd+=" --delete=${active[partnum]}"
            sgdisk_cmd+=" --new=${active[partnum]}:"
            sgdisk_cmd+="$SYSTEM[$active[devpath],start]}:"
            sgdisk_cmd+="$SYSTEM[$active[devpath],end]} "
            sgdisk_cmd+="${active[parent,devpath]}"
            eval $outputvar'+=("$sgdisk_cmd $sgdisk_msg")'
        fi

        if [[ ${active[type]} == partition ]] && ! activeIsNoclobber
        then

            sgdisk_cmd="sgdisk"

            if [[ ${(L)active[size]} =~ "^max" ]]; then
                sgdisk_cmd+=" --largest-new=${active[partnum]}"
                #moving to 0 in lieu of specific partnum
                #sgdisk_cmd+=" --largest-new=0"
                sgdisk_msg="# create partition filling remaining space"
            elif [[ ${(L)active[size]} =~ "ram" ]]; then
                sgdisk_cmd+=" --new=${active[partnum]}:0:"
                #moving to 0 in lieu of specific partnum
                #sgdisk_cmd+=" --new=0:0:"
                sgdisk_cmd+="$(( ${${(f)$(cat /proc/meminfo \
                   )}//(#bi)memtotal:[[:space:]]#([[:digit:]]#)*/$match} \
                   / 1000000 ))G"
                sgdisk_msg="# create partition matching system ram size"
            else
                sgdisk_cmd+=" --new=${active[partnum]}:0:+${active[size]}"
                #moving to 0 in lieu of specific partnum
                #sgdisk_cmd+=" --new=0:0:+${active[size]}"
                sgdisk_msg="# create fixed size partition"
            fi

            [[ -n "${(L)active[bootable]:-}" ]] && \
            sgdisk_cmd+=(" --attributes=${active[partnum]}:set:0")

            [[ -n "${active[code]:-}" ]] && \
            sgdisk_cmd+=" --typecode=${active[partnum]}:${active[code]}"

            [[ -n "${active[label]:-}" ]] && \
                sgdisk_cmd+=" --change-name=${active[partnum]}:${(q-)active[label]}"

            eval $outputvar'+=("$sgdisk_cmd $sgdisk_msg")'

        fi

    done

    # we processed one set of siblings, now walk down each branch
    for record in $children; do
        $0 --start_at $record --ignore_env $ignore_env
    done
}
genEncryption () {

    . <(localopts start_at: multipass:)

    typeset -a children
    children=($(children --of "${start_at:-}"))

    for record in $children
    do

        . <(active $record)

        if [[ ${active[type]} == encryption ]]; then

            sectionHeader encryption

            # if there is no passphrase from the template item
            # and we haven't already queried for the passphrase
            # (or we have multipass set), then output the query
            # script block
            if [[ -z ${active[pass]:-} ]] && ! ${PASSQUERY:-false}
            then
                # as long as multipass isn't set, then make this
                # the only time we create the query block
                if ! ${(P)multipass:-false} && ! ${PASSQUERY:-false}
                then
                    typeset -g PASSQUERY=true
                fi
                m1=Passphrase m2=Confirmation ta='\\nTry again\\n' r="read -Ers "
                eval $outputvar'+=(
                "\\n# Query and confirm passphrase"
                "while ! \${\${\${pass::=\$(\\"
                "$r\"?$m1: \")}:#\$(\\"
                "$r\"?$m2: \")}:+false};" "do print \"${(q)ta}\"; done")'
            elif [[ -n ${active[pass]:-} ]]
            then
                eval $outputvar'+=(
                "# Saving a passphrase in a file is obviously insecure"
                "pass=${(q)active[pass]}")'
            fi
            luksf="print -r \$pass | "
            luksf+="cryptsetup ${s::=${OPTIONS[luks,format]:-}}${s:+ }"
            luksf+="${s::=${active[luksformat]:-}}${s:+ }"
            luksf+="luksFormat ${active[devpath]}"
            lukso="print -r \$pass | "
            lukso+="cryptsetup open "
            lukso+="${s::=${OPTIONS[luks,open]:-}}${s:+ }"
            lukso+="${s::=${active[luksopen]:-}}${s:+ }"
            lukso+="${s::=${active[ssd]+${OPTIONS[luks,open,ssd]:-}}}${s:+ }"
            lukso+="${active[devpath]} "
            lukso+="${(q-)active[label]:-${active[devpath]//\//_}} "
            ancestorOrSelfIsNoclobber --index $record \
                || eval $outputvar'+=("\n# LUKS formatting" "$luksf")'
            eval $outputvar'+=("\n# LUKS open" "$lukso")'
        fi

    done

    # we processed one set of siblings, now walk down each branch
    for record in $children; do
        $0 --start_at $record --multipass $multipass
    done

}
genSwap () {

    . <(localopts start_at: )

    typeset -a children
    children=($(children --of "${start_at:-}"))

    for record in $children
    do

        . <(active $record)

        if [[ ${active[type]} == swap ]]
        then

            sectionHeader swap

            mkswap="mkswap "
            swapon="swapon "

            if [[ -n ${active[label]:-} ]]
            then

                swapid="-L ${(q-)active[label]}"

            else

                msg1="# Get swap uuid (add --label on swap to use instead)\n"
                msg2=" # get swap uuid if no label"
                cmd="swap_uuid=\"\$(lsblk -no UUID ${active[devpath]})\""
                eval $outputvar'+=( "$msg1$cmd$msg2" )'
                swapid="-U \$swap_uuid"

            fi

            swapssd+="${s::=${active[ssd]+${OPTIONS[swap,ssd]:-}}}${s:+ }"
            mkswap+="$swapid ${active[devpath]}"
            swapon+="$swapid $swapssd${active[devpath]}"

            ancestorOrSelfIsNoclobber --index $record \
                || eval $outputvar'+=("$mkswap # make swap device")'
            eval $outputvar'+=("$swapon # activate swap device")'

        fi

    done

    # we processed one set of siblings, now walk down each branch
    for record in $children; do
        $0 --start_at $record
    done

}
genFilesystem () {

    . <(localopts start_at: )

    typeset -a children
    children=($(children --of "${start_at:-}"))

    for record in $children
    do

        . <(active $record)

        if [[ ${active[type]} == filesystem ]] \
            && ! ancestorOrSelfIsNoclobber --index $record
        then

            sectionHeader filesystem

            mkfscmd="mkfs.${f::=${active[fstype]}} "
            mkfscmd+="${s::=${(e)OPTIONS[mkfs]:-}}${s:+ }"
            mkfscmd+="${s::=${(e)OPTIONS[mkfs,$f]:-}}${s:+ }"
            (( ${+active[ssd]} )) && {
            mkfscmd+="${s::=${(e)OPTIONS[mkfs,ssd]:-}}${s:+ }"
            mkfscmd+="${s::=${(e)OPTIONS[mkfs,$f,ssd]:-}}${s:+ }"
            }
            mkfscmd+="${s::=${active[mkfsoptions]:-}}${s:+ }"
            mkfscmd+="${active[devpath]}"
            eval $outputvar'+=(
                "$mkfscmd  # make filesystem"
                )'
        fi

    done

    # we processed one set of siblings, now walk down each branch
    for record in $children; do
        $0 --start_at $record
    done

}
genMounts () {

    . <(localopts start_at: )

    typeset -a children
    children=($(children --of "${start_at:-}"))

    : ${(AA)mountpoint_records::=${(kv)STORAGE[(I)*,mountpoint]%%,mountpoint}}
    : ${(A)ordered_mountpoints::=${(nv)mountpoint_records}}

    sectionHeader mount

    for mountpoint in $ordered_mountpoints; do

        record=${(k)mountpoint_records[(r)$mountpoint]}
        . <(active $record)
        mountpath="${${:-${(P)mountroot%/}/${active[mountpoint]#/}}%/}"

        if [[ ${active[type]} != subvolume ]]
        then
            mountopts=()
            mountopts+=(
                "${OPTIONS[mount]}"
                "${OPTIONS[mount,${active[fstype]:-}]:-}"
                )
            (( ${+active[ssd]} )) && {
                mountopts+=(
                "${OPTIONS[mount,ssd]}"
                "${OPTIONS[mount,${active[fstype]:-},ssd]:-}"
                )
            }
            typeset -a mountcmd
            mountcmd=("mount")
            mountcmd+=("${(j:,:)${(u)=${(s:,:)mountopts}}}")
            mountcmd+=("${active[devpath]} ${mountpath}")
            eval $outputvar'+=("$mountcmd")'
        else # subvolume
            eval $outputvar'+=(
            "btrfs subvolume create ${(q-)mountpath}"
            )'
        fi

    done

}
:<< \
------------------------------------------------------------------------------
miscellaneous utility functions
------------------------------------------------------------------------------
hangingIndent () {
    . <(localopts linespacing wrapcol: text: margin: indent:)
    text=${text:-$1}
    wrapcol=${wrapcol:-$COLUMNS}
    margin=${margin:-0}
    indent=${indent:-0}

    # wrap lines with leaders
    typeset text_head="" text_tail=""
    typeset -a wrapped

    text="${(l.$margin...):-}$text"
    wrapped=(${(f)${:-"$(print -- ${(e)text} | fold -s -w $wrapcol)"}})
    text_head=${wrapped[1]:-}
    text="${text[$((${#text_head}+1)),-1]## #}"
    wrapped=(${(f)${:-"$(print -- ${(e)text} | fold -s -w $(($wrapcol-$margin-$indent)))"}})
    print -- "$text_head"
    [[ -z $wrapped ]] && ${linespacing:-false} && print || :
    [[ -z $wrapped ]] ||
        print -l -- "${(l.$(($margin+$indent))...):-}"${^wrapped}${linespacing+\\n}
}
fail () {
    ${DEBUG:-false} && debugDump
    teelog --category FAILURE --color red "$*"
    print 1>&2
    DEBUG=true
    exit 1
}
display () {
    # just print, no logging
    teelog --nolog --color default ${=*}
}
report () {
    teelog --category report --color green ${=*}
}
teelog () {
    # print if not in quiet mode
    # write to named arrays for later log/script output
    . <(localopts category: color: noprint nolog verbose)
    if [[ -z ${category:-} ]] && ! ${nolog:-false}
    then
        print "MISSING CATEGORY" 1>&2; exit 1
    elif ! ${nolog:-false}
    then
        typeset -ag CATEGORIES
        CATEGORIES+=($category)
        typeset -ag REPORT_${(U)category}
        eval REPORT_${(U)category}'+=("${${=@}}")'
    fi
    if ! ${noprint:-false} && ! ${QUIET:-false} && \
       [[ ${VERBOSE:-false} == ${verbose:-${VERBOSE:-false}} ]]
    then
        if ! { ${verbose:-false} && ! ${VERBOSE:-false} }
        then
            print -n "\\n${COLOR[${color:-default}]:-}" 1>&2;
            print -n "$(print "${(U)category:-}${category:+: }${=*}" \
                | fold -sw $COLUMNS)" 1>&2;
            print "${COLOR[default]:-}" 1>&2;
        fi
    fi
}
reportLog () {
    # dump report category arrays to script/log
    (( ${+CATEGORIES} )) || return 0
    typeset w=${width:-72} # preserve external scope
    typeset cat lineitem width=$w
    typeset category lineitem
    print "\n\n# ${(U)SCRIPTNAME} ${(j:/:)${:-${(Uu)^=CATEGORIES}S}}\n#"
    print "# The following comment sections contain messages"
    print "# output during the $SCRIPTNAME processing"
    typeset -a categories
    categories=(${(Uu)=CATEGORIES})
    typeset testvalue
    () { for category in $categories
    do
        [[ -n ${(P)${:-REPORT_$category}} ]] || continue
        print "#\n# ${category}S ${___::=${(r:$(($width-${#category}-4))::==:):-}}"
        for lineitem in ${(@P)${:-REPORT_$category}}
        do
            print "#"
            print -l -- "# "${(@f)^"$(print $lineitem | fold -sw $width)"}
        done
    done }
}
reportInferred () {
    teelog --category inference --color cyan ${=*}
}
alert () {
    teelog --category alert --color cyan ${=*}
}
warn () {
    teelog --category warning --color yellow ${=*}
}
shrinkWrap () {
    # smartWraps argument but first collapses to words, losing semantic space
    . <(localopts wrap: indent: output: padding: margin:)
    smartWrap ${=@} \
        ${wrap:+--wrap $wrap} \
        ${margin:+--margin $margin} \
        ${indent:+--indent $indent} \
        ${output:+--output $output} \
        ${padding:+--padding $padding} \
}
smartWrap () {
    # smartWrap "STRING_TO_PRINT" \
    #       [--output OUTPUT_ARRAY_NAME] \
    #       [--padding RIGHT_PADDING_INTEGER] \
    #       [--indent LEFT_INDENT_INTEGER] \
    #       [--margin LEFT_RIGHT_PADDING_INDENT_INTEGER]
    #
    # (without --output value, prints output to standard output)

    . <(localopts wrap: indent: output: padding: margin:)

    typeset w i p l print c=""

    w=${wrap:-$COLUMNS}
    i=${indent:-${margin:-0}}
    p=${padding:-${margin:-0}}
    l=${(l.$i...):-}
    print=:
    [[ -n ${output:-} ]] && { typeset -ag $output; print=false }

    # the following expansion turns paragraphs with line breaks into single
    # paragraphs with no line breaks,  while indented lines remain single
    # paragraphs (mimics markdown style wrapping)
    typeset -a e
    e=(
    '""'
    '${(Qs:INDENTEDLINE:)^'
    '${(j:INDENTEDLINE:)'
    '${'
    '${(@qs:NEWLINE :)'
    '${(j: :)^'
    '${'
    '${'
    '${(@qf)'
    '${@}'
    '}'
    '//(#m)*/${${:-${(Q)MATCH}}:-NEWLINE NEWLINE}'
    '}'
    '//(#m)(#s)[[:blank:]]##/INDENTEDLINE$MATCH}'
    '}'
    '}#INDENTEDLINE}'
    '}'
    '}'
    )

    typeset notblock wrapline
    typeset -a wraplines
    for line in "${(@ej::)e#\"\"}"
    do

        # trim indented lines, don't wrap
        #if (( ${(M)#${(Q)line}## #} > 2 )); then
        # adding requirement of blank line before indent block

        if (( ${(M)#${(Q)line}## #} > 2 )) && [[ -z ${c} ]]; then
            wrapline="$(\
            print -P -- "$l%$((w-i-p))>...>${(l.$i...):-}${line}")"
            $print && print -- "$wrapline" || eval $output'+=($wrapline)' 

        # else wrap paragraphs
        else

            #wrapline="$(print -- $line | fold -s -w $w)"
            #$print && print -- "$wrapline" || eval $output'+=("$wrapline")'
            wraplines=("${:-$l${(@f)^$(print -- \
                $line | fold -s -w $((w-i-p)))}}")
            $print && print -l -- $wraplines || \
                eval $output'+=("${(@)^wraplines}")'
            notblock=true
        fi
        c=${${line:0:1}##[[:blank:]]#}
    done

}
valueInListOrListAbsent () {
    # valueInListOrListAbsent  LIST value
    # valueInListOrListAbsent "LIST[subscript]" value
    # Will return 0/true if no valid test array is found
    # (i.e. this presumes validity in cases where no test data available)
    (( ${(P)+${1:-}} )) || return 0 # no list
    [[ -n ${(A)value::=${2:-}} ]] || return 0 # no value
    [[ -n ${${(P)=${1:-}}:*value} ]]
}
valueInList () {
    # valueInList  LIST value
    # valueInList "LIST[subscript]" value
    # Will FAIL and exit 1 if no valid test array is found
    # If both test and list are empty, passes true/0 value
    # If only one is empty, then fails
    (( ${(P)+${1:-}} )) || {
        printErr 0 "No list named $1 found in $0!"; exit 1 }
    [[ -z ${(A)value::=${2:-}} ]] && [[ -z ${(P)1} ]] && return 0
    [[ -n ${${(P)=${1:-}}:*value} ]]
}
localopts () {
    # output parameter typeset, optarg parsing commands to be executed by
    # function in order to make this logic reusable but still retain
    # function-local variable scope
    #
    # must be called inside a function using this syntax:
    #
    # . <(localopts optname optargname:)
    #
    # optargs are specified with the standard zparseopts syntax other than no
    # leading - is required for long argument names. Any leading - passed to
    # this function as arguments are ignored. single characters are treated
    # as standard single-dash prefixed options, multiple character opt names
    # are treated as extended double-dash prefixed options.
    #
    # boolean options are assigned "true" values, otherwise are left unset

    [[ -n $@ ]] || return 0

    # grab just the boolean options (we'll use these in the eval below)
    print "typeset -a _boolopts; _boolopts=("${${=@}:#*:-#}" '')"

    # this section outputs something like:
    #   typeset myoption myboolean
    #   unset myoption myboolean
    # making sure that all parameters are local to the function and cleared
    # (localopts may be called repeatedly in a function and we want to
    # ensure that it always outputs a known state, reseting values it is
    # expected to parse)
    typeset -a cleanopts; cleanopts=(${${@##-#}%%(:|+)*})
    print "setopt TYPESET_SILENT"   # else our next typeset may output
                                    # existing local parameter values
    print "typeset $cleanopts; "    # make variables local to function
    print   "unset $cleanopts; "    # clear these local variables

    # this section outputs something like:
    #   zparseopts -D -E -A o -- -myoption: -myboolean
    typeset -a e
    e=(
    '${(o)@'          '# expand all values passed to this function, sorted
                         to avoid zparseopts getting confused by substring
                         matches'
    '//(#b)'          '# search using back references such as ${match[1]}'
    '(#s)'            '# search from beginning of string'
    '-#'              '# match and discard leading dashes'
    '(*)'             '# match and retain as backreference the remainder'
    '/'               '# replace with...'
    '${(l.'           '# make an arbitrary length string (use left padding)'
    '$(('             '# the length of which is calculated by...'
    '${#match[1]'     '# the length of the first element of the match array'
    '//[^[:WORD:]]/}' '# but just the [:WORD:] characters'
    '>1?1'            '# if more than 1 WORD option name, make a SINGLE...'
    ':0))'            '# else if 1 WORD character option name, make NO...'
    '..-.):-}'        '# ...dash prefix'
    '$match[1]'       '# followed by the actual match'
    '}'
    ) 
    # evaluated, joined 'e' with no '#' comments
    print 'zparseopts -D -E -A o -- '${(ej..)e:#\#*}';'

    # this section outputs something like:
    #   typeset myoption='my option value'; typeset myboolean=true
    e=(
    '${(@k)o'    '# all keys of the o array from zparseopts'
    '//(#b)'     '# search using back references such as ${match[1]}'
    '(#s)'       '# search from beginning of string'
    '(-#)'       '# match and retain leading dashes as $match[1]'
    '(*)'        '# match and retain remainder of key as $match[2]'
    '/'          '# replace with...'
    '$match[2]'  '# use just the WORD component ("keyname" from "--keyname")'
    '='          '# use it as a parameter name and assign it a value'
    '${(q-)'     '# the assigned value should be simple quoted'
    'o[${(j..)match}]' '# join the "--" match[1] and the "keyname" match[2]'
    ':-'                            '# if value is missing (but opt was present'
    '${${(M)_boolopts:#${match[2]}}' '# and if it matches the boolean opts list'
    ':+true}}}'                     '# set the value to true'
    ';'
    )
    print 'eval '${(j..)e:#\#*}
}
debugCapture () {
    if [[ -n ${DEBUGLOG:-} ]]
    then
        typeset -p $1 >> $DEBUGLOG
        print >> $DEBUGLOG
    fi
}

# vim: set filetype=sh : 
